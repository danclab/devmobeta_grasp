---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 


```{r PC7_GCA_ASQ3_Analysis}
library(dplyr)
library(car)
library(ggplot2)
library(lme4)
library(interactions)
library(emmeans)
library(ggeffects)
library(reshape2)
library(tidyr)
three_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_three.csv')
six_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_six.csv')
twelve_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_twelve.csv')

asq3_3m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/3_ASQ-4months_scores.csv')
asq3_6m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/6_ASQ-6months_scores.csv')
asq3_12m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/12_ASQ-12months_scores.csv')

print(colnames(asq3_3m))
print(colnames(asq3_6m))
print(colnames(asq3_12m))

# Fusion des données PC
merged_df <- bind_rows(
  mutate(three_df, df_source = "three", age_months = 3),
  mutate(six_df, df_source = "six", age_months = 6),
  mutate(twelve_df, df_source = "twelve", age_months = 12)
) %>%
  arrange(subject)

# convertit variable age en numérique 
merged_df$age[merged_df$age == 'three'] <- 3
merged_df$age[merged_df$age == 'six'] <- 6
merged_df$age[merged_df$age == 'twelve'] <- 12
merged_df$age <- as.numeric(merged_df$age)

# Préparation des données ASQ3
asq3_3m$age_months <- 3
asq3_6m$age_months <- 6
asq3_12m$age_months <- 12

# Fusion des données ASQ3
asq3_all <- bind_rows(asq3_3m, asq3_6m, asq3_12m) %>%
  select(subject, age_months, communication, gmotor, fmotor, pbsolving, social)

# Fusion des données PC avec ASQ3
data_combined <- merged_df %>%
  left_join(asq3_all, by = c("subject", "age_months"))

# Vérification de la fusion
cat("Nombre de lignes avant fusion:", nrow(merged_df), "\n")
cat("Nombre de lignes après fusion:", nrow(data_combined), "\n")
cat("Nombre de sujets avec données ASQ3:", sum(!is.na(data_combined$communication)), "\n")

# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
  
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC7 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC7 = mean(PC7, na.rm = TRUE),
    se_PC7 = sd(PC7, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC7, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC7 - se_PC7, ymax = mean_PC7 + se_PC7), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC7 par âge et epoch",
       x = "Âge (mois)", y = "PC7 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC7 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat(" Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC7 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC7") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat(" Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC7 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC7") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat(" Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat(" Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
      
          }
         )
      }
    }
  }
}

# Exécuter le diagnostic avant l'analyse
diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat(" ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}

# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat(" Epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat(" ? Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("  Statut inconnu\n")
      }
    }
  } else {
    cat("  Résultats non disponibles\n")
  }
}

save_asq3_results <- function() {
  output_file <- "ASQ3_PC7_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC7 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

save_asq3_results()

```
```{r PC1_GCA_ASQ3_Analysis}
# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}
    
# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC1 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC1 = mean(PC1, na.rm = TRUE),
    se_PC1 = sd(PC1, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC1, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC1 - se_PC1, ymax = mean_PC1 + se_PC1), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC1 par âge et epoch",
       x = "Âge (mois)", y = "PC1 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC1 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat(" Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC1 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC1") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat(" Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat(" Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC1 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                 
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC1") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat(" Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat(" Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
            # Graphique d'interaction simple
            if (length(interaction_effects) > 0) {
              cat("Création du graphique d'interaction...\n")
              tryCatch({
                # Créer des niveaux de la variable ASQ3 pour la visualisation
                epoch_data$asq3_level <- cut(epoch_data[[asq3_domain]], 
                                             breaks = 3, 
                                             labels = c("Faible", "Moyen", "Élevé"))
                
                p_interaction <- ggplot(epoch_data, aes(x = age, y = PC1, color = asq3_level)) +
                  geom_smooth(method = "loess", se = TRUE) +
                  geom_point(alpha = 0.5) +
                  labs(title = paste("Interaction Age ×", asq3_domain, "- epoch:", epoch_val),
                       x = "Âge (mois)", y = "PC1",
                       color = paste("Niveau", asq3_domain)) +
                  theme_bw()
                
                print(p_interaction)
                cat(" Graphique d'interaction créé\n")
                
              }, error = function(e) {
                cat(" Erreur graphique interaction:", e$message, "\n")
              })
            }
            
          }, error = function(e) {
            cat(" Erreur modèle pour epoch", epoch_val, ":", e$message, "\n")
            epoch_results[[epoch_val]] <- list(
              error = e$message,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data)
            )
          })
          
        } else {
          cat(" Variable ASQ3 pas assez variable pour cette epoch (", length(unique_values), " valeurs uniques)\n")
          epoch_results[[epoch_val]] <- list(
            issue = "insufficient_variability",
            epoch = epoch_val,
            domain = asq3_domain,
            n_obs = nrow(epoch_data)
          )
        }
        
      } else {
        cat(" Données insuffisantes pour epoch", epoch_val, "(n =", nrow(epoch_data), ")\n")
        epoch_results[[epoch_val]] <- list(
          issue = "insufficient_data",
          epoch = epoch_val,
          domain = asq3_domain,
          n_obs = nrow(epoch_data)
        )
      }
    }
    
    return(epoch_results)
    
  } else {
    cat(" Données insuffisantes globalement (n =", nrow(subset_data), ")\n")
    return(list(global_issue = "insufficient_data", n_obs = nrow(subset_data)))
  }
}


diagnose_data()

cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat(" ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}


# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat("epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat(" ? Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("  Statut inconnu\n")
      }
    }
  } else {
    cat("  Résultats non disponibles\n")
  }
}


# Fonction pour sauvegarder tous les résultats
save_asq3_results <- function() {
  output_file <- "ASQ3_PC1_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC1 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

# Sauvegarder les résultats
save_asq3_results()


```

```{r PC2_GCA_ASQ3_Analysis}
library(dplyr)
library(car)
library(ggplot2)
library(lme4)
library(interactions)
library(emmeans)
library(ggeffects)
library(reshape2)
library(tidyr)
three_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_three.csv')
six_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_six.csv')
twelve_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_twelve.csv')

asq3_3m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/3_ASQ-4months_scores.csv')
asq3_6m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/6_ASQ-6months_scores.csv')
asq3_12m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/12_ASQ-12months_scores.csv')

print(colnames(asq3_3m))
print(colnames(asq3_6m))
print(colnames(asq3_12m))

# Fusion des données PC
merged_df <- bind_rows(
  mutate(three_df, df_source = "three", age_months = 3),
  mutate(six_df, df_source = "six", age_months = 6),
  mutate(twelve_df, df_source = "twelve", age_months = 12)
) %>%
  arrange(subject)

# convertit variable age en numérique 
merged_df$age[merged_df$age == 'three'] <- 3
merged_df$age[merged_df$age == 'six'] <- 6
merged_df$age[merged_df$age == 'twelve'] <- 12
merged_df$age <- as.numeric(merged_df$age)

# Préparation des données ASQ3
asq3_3m$age_months <- 3
asq3_6m$age_months <- 6
asq3_12m$age_months <- 12

# Fusion des données ASQ3
asq3_all <- bind_rows(asq3_3m, asq3_6m, asq3_12m) %>%
  select(subject, age_months, communication, gmotor, fmotor, pbsolving, social)

# Fusion des données PC avec ASQ3
data_combined <- merged_df %>%
  left_join(asq3_all, by = c("subject", "age_months"))

# Vérification de la fusion
cat("Nombre de lignes avant fusion:", nrow(merged_df), "\n")
cat("Nombre de lignes après fusion:", nrow(data_combined), "\n")
cat("Nombre de sujets avec données ASQ3:", sum(!is.na(data_combined$communication)), "\n")

# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC2 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC2 = mean(PC2, na.rm = TRUE),
    se_PC2 = sd(PC2, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC2, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC2 - se_PC2, ymax = mean_PC2 + se_PC2), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC2 par âge et epoch",
       x = "Âge (mois)", y = "PC2 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC2 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat(" Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC2 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC2") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat(" Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC2 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC2") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat(" Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat(" Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            # GRAPHIQUES BASÉS SUR LES PRÉDICTIONS DU MODÈLE
            # ===============================================
            
            if (length(interaction_effects) > 0) {
              cat("Création des graphiques basés sur les prédictions du modèle...\n")
              tryCatch({
                
                # ÉTAPE 1 : DÉFINIR LES NIVEAUX ASQ3 REPRÉSENTATIFS
                # ================================================
                # Utilise les percentiles pour représenter la distribution réelle
                asq3_values <- quantile(epoch_data[[asq3_domain]], 
                                        probs = c(0.25, 0.5, 0.75), 
                                        na.rm = TRUE)
                
                cat("Niveaux ASQ3 utilisés:", paste(round(asq3_values, 2), collapse = ", "), "\n")
                
                # ÉTAPE 2 : PRÉDICTIONS POUR LES EFFETS POLYNOMIAUX
                # ================================================
                
                # 2a. Effet linéaire (poly1) selon niveaux ASQ3
                pred_poly1 <- ggpredict(lmer_mod, 
                                        terms = c("poly1 [all]", 
                                                  paste0(asq3_domain, " [", 
                                                         paste(round(asq3_values, 2), collapse = ","), "]")))
                
                # 2b. Effet quadratique (poly2) selon niveaux ASQ3
                pred_poly2 <- ggpredict(lmer_mod, 
                                        terms = c("poly2 [all]", 
                                                  paste0(asq3_domain, " [", 
                                                         paste(round(asq3_values, 2), collapse = ","), "]")))
                
                # ÉTAPE 3 : PRÉPARATION DES DONNÉES POUR VISUALISATION
                # ===================================================
                
                # Convertir en data.frames et ajouter identifiants
                pred_poly1_df <- as.data.frame(pred_poly1)
                pred_poly1_df$polynomial <- "Linéaire (poly1)"
                pred_poly1_df$effect_type <- "Tendance constante"
                
                pred_poly2_df <- as.data.frame(pred_poly2)
                pred_poly2_df$polynomial <- "Quadratique (poly2)"  
                pred_poly2_df$effect_type <- "Accélération/Décélération"
                
                # Combiner les deux types d'effets
                pred_combined <- rbind(pred_poly1_df, pred_poly2_df)
                
                # Renommer les groupes pour l'affichage
                pred_combined$asq3_level <- factor(pred_combined$group,
                                                   levels = as.character(round(asq3_values, 2)),
                                                   labels = paste0(asq3_domain, " P", c(25, 50, 75)))
                
                # ÉTAPE 4 : GRAPHIQUE DES EFFETS POLYNOMIAUX
                # =========================================
                
                p_effects <- ggplot(pred_combined, aes(x = x, y = predicted)) +
                  # Intervalles de confiance
                  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = asq3_level), 
                              alpha = 0.2) +
                  # Lignes principales
                  geom_line(aes(color = asq3_level, linetype = polynomial), 
                            size = 1.3) +
                  # Séparation par type d'effet
                  facet_wrap(~effect_type, scales = "free_x") +
                  
                  labs(title = paste("Effets polynomiaux selon", asq3_domain, "- epoch:", epoch_val),
                       subtitle = "Prédictions du modèle mixte avec intervalles de confiance à 95%",
                       x = "Valeur polynomiale transformée", 
                       y = "PC2 prédit (unités standardisées)",
                       color = "Niveau ASQ3",
                       fill = "Niveau ASQ3",
                       linetype = "Composante") +
                  
                  # Esthétique
                  scale_color_brewer(type = "qual", palette = "Dark2") +
                  scale_fill_brewer(type = "qual", palette = "Dark2") +
                  scale_linetype_manual(values = c("solid", "dashed")) +
                  theme_bw() +
                  theme(
                    plot.title = element_text(size = 13, face = "bold"),
                    plot.subtitle = element_text(size = 11),
                    strip.text = element_text(size = 10, face = "bold"),
                    legend.position = "bottom",
                    legend.title = element_text(size = 10),
                    axis.text = element_text(size = 9)
                  )
                
                print(p_effects)
                cat("? Graphique des effets polynomiaux créé\n")
                
                # ÉTAPE 5 : TRAJECTOIRES DÉVELOPPEMENTALES COMPLÈTES
                # =================================================
                
                # 5a. Créer une séquence fine d'âges pour des courbes lisses
                age_range <- range(epoch_data$age, na.rm = TRUE)
                age_seq <- seq(age_range[1], age_range[2], length.out = 100)
                
                # 5b. Grille de prédiction : tous les âges × tous les niveaux ASQ3
                pred_grid <- expand.grid(
                  age = age_seq,
                  asq3_val = asq3_values
                )
                
                # 5c. Appliquer la même transformation polynomiale que le modèle original
                # CRUCIAL : Utilise exactement la même fonction que votre analyse principale
                pred_grid <- code.poly(df = pred_grid, predictor = "age", poly.order = 2, 
                                       orthogonal = TRUE, draw.poly = FALSE)
                
                # 5d. Ajouter la variable ASQ3 avec le bon nom
                pred_grid[[asq3_domain]] <- pred_grid$asq3_val
                
                # 5e. Créer les étiquettes pour l'affichage
                pred_grid$asq3_level <- factor(pred_grid$asq3_val, 
                                               levels = asq3_values,
                                               labels = paste0(asq3_domain, " P", c(25, 50, 75)))
                
                # 5f. PRÉDICTIONS DU MODÈLE (effets fixes seulement)
                pred_grid$predicted <- predict(lmer_mod, newdata = pred_grid, re.form = NA)
                
                # 5g. Calculer les intervalles de confiance (approximation)
                # Note: Pour des IC exacts, il faudrait utiliser bootMer(), mais c'est plus lent
                pred_matrix <- model.matrix(~ poly1 * get(asq3_domain) + poly2 * get(asq3_domain), 
                                            data = pred_grid)
                pred_var <- diag(pred_matrix %*% vcov(lmer_mod) %*% t(pred_matrix))
                pred_grid$se <- sqrt(pred_var)
                pred_grid$conf_low <- pred_grid$predicted - 1.96 * pred_grid$se
                pred_grid$conf_high <- pred_grid$predicted + 1.96 * pred_grid$se
                
                # ÉTAPE 6 : GRAPHIQUE DES TRAJECTOIRES DÉVELOPPEMENTALES
                # =====================================================
                
                # 6a. Préparer les données observées avec classification ASQ3
                epoch_data$asq3_quartile <- cut(epoch_data[[asq3_domain]], 
                                                breaks = c(-Inf, asq3_values, Inf),
                                                labels = c("< P25", "P25-P50", "P50-P75", "> P75"),
                                                include.lowest = TRUE)
                
                # 6b. Créer le graphique principal
                p_trajectories <- ggplot() +
                  
                  # Intervalles de confiance des prédictions
                  geom_ribbon(data = pred_grid,
                              aes(x = age, ymin = conf_low, ymax = conf_high, fill = asq3_level),
                              alpha = 0.2) +
                  
                  # Trajectoires prédites (lignes principales)
                  geom_line(data = pred_grid,
                            aes(x = age, y = predicted, color = asq3_level),
                            size = 2, alpha = 0.9) +
                  
                  # Points observés (données réelles)
                  geom_point(data = epoch_data[!is.na(epoch_data$asq3_quartile), ],
                             aes(x = age, y = PC2, color = asq3_quartile),
                             alpha = 0.6, size = 2, shape = 16) +
                  
                  # Moyennes observées par âge et niveau ASQ3
                  stat_summary(data = epoch_data[!is.na(epoch_data$asq3_quartile), ],
                               aes(x = age, y = PC2, color = asq3_quartile),
                               fun = mean, geom = "point", size = 4, shape = 17, alpha = 0.8) +
                  
                  # Esthétique et labels
                  labs(title = paste("Trajectoires développementales de PC2 selon", asq3_domain),
                       subtitle = paste("Epoch:", epoch_val, "? Lignes = prédictions du modèle ? Points = données observées ? Triangles = moyennes"),
                       x = "Âge (mois)", 
                       y = "PC2 (score standardisé)",
                       color = paste("Niveau", asq3_domain),
                       fill = paste("Niveau", asq3_domain)) +
                  
                  # Couleurs et thème
                  scale_color_brewer(type = "qual", palette = "Set1") +
                  scale_fill_brewer(type = "qual", palette = "Set1") +
                  scale_x_continuous(breaks = unique(epoch_data$age)) +
                  theme_bw() +
                  theme(
                    plot.title = element_text(size = 14, face = "bold"),
                    plot.subtitle = element_text(size = 11),
                    legend.position = "bottom",
                    legend.title = element_text(size = 11, face = "bold"),
                    legend.text = element_text(size = 10),
                    axis.title = element_text(size = 12),
                    axis.text = element_text(size = 10),
                    panel.grid.minor = element_blank()
                  ) +
                  
                  # Guides pour améliorer la légende
                  guides(
                    color = guide_legend(override.aes = list(size = 3, alpha = 1)),
                    fill = guide_legend(override.aes = list(alpha = 0.3))
                  )
                
                print(p_trajectories)
                cat("? Graphique des trajectoires développementales créé\n")
                
                # ÉTAPE 7 : STATISTIQUES DESCRIPTIVES POUR INTERPRÉTATION
                # ======================================================
                
                cat("\n--- STATISTIQUES POUR INTERPRÉTATION ---\n")
                
                # Différences entre niveaux ASQ3 à chaque âge
                age_effects <- pred_grid %>%
                  select(age, asq3_level, predicted) %>%
                  pivot_wider(names_from = asq3_level, values_from = predicted) %>%
                  mutate(
                    diff_P75_P25 = get(paste0(asq3_domain, " P75")) - get(paste0(asq3_domain, " P25")),
                    diff_P50_P25 = get(paste0(asq3_domain, " P50")) - get(paste0(asq3_domain, " P25"))
                  )
                
                cat("Différences prédites entre niveaux ASQ3 :\n")
                cat("À 3 mois - P75 vs P25:", round(age_effects$diff_P75_P25[1], 3), "\n")
                cat("À 12 mois - P75 vs P25:", round(age_effects$diff_P75_P25[nrow(age_effects)], 3), "\n")
                
                # Pentes développementales par groupe
                slopes <- pred_grid %>%
                  group_by(asq3_level) %>%
                  do(model = lm(predicted ~ age, data = .)) %>%
                  mutate(slope = map_dbl(model, ~ coef(.)[2]))
                
                cat("Pentes développementales (changement par mois) :\n")
                for(i in 1:nrow(slopes)) {
                  cat("-", slopes$asq3_level[i], ":", round(slopes$slope[i], 4), "\n")
                }
                
                cat("? Graphiques basés sur le modèle créés avec succès\n")
                
              }, error = function(e) {
                cat("? Erreur dans les graphiques basés sur le modèle:", e$message, "\n")
                cat("Détails:", paste(e$call, collapse = " "), "\n")
              })
            }
          }
          )
        }
      }
    }
  }
  
  # Exécuter le diagnostic avant l'analyse
  diagnose_data()
  
  # Exécuter l'analyse corrigée pour chaque domaine ASQ3
  cat("\n", paste(rep("=", 80), collapse = ""), "\n")
  cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
  cat(paste(rep("=", 80), collapse = ""), "\n")
  
  asq3_results_corrected <- list()
  
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n Traitement du domaine:", domain, "\n")
      results <- analyze_asq3_moderator(domain)
      asq3_results_corrected[[domain]] <- results
    } else {
      cat(" ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
    }
  }
  
  # Résumé final amélioré
  cat("\n", paste(rep("=", 80), collapse = ""), "\n")
  cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
  cat(paste(rep("=", 80), collapse = ""), "\n")
  
  for (domain in names(asq3_results_corrected)) {
    cat("\n DOMAINE:", toupper(domain), "\n")
    cat(paste(rep("-", 40), collapse = ""), "\n")
    
    domain_results <- asq3_results_corrected[[domain]]
    
    if (is.list(domain_results) && !is.null(names(domain_results))) {
      for (epoch_name in names(domain_results)) {
        epoch_result <- domain_results[[epoch_name]]
        cat(" Epoch", epoch_name, ":")
        
        if ("model" %in% names(epoch_result)) {
          n_sig <- length(epoch_result$significance$significant_effects)
          cat("  Analysée (", n_sig, " effets significatifs)\n")
        } else if ("error" %in% names(epoch_result)) {
          cat(" ? Erreur:", epoch_result$error, "\n")
        } else if ("issue" %in% names(epoch_result)) {
          cat("  Problème:", epoch_result$issue, "\n")
        } else {
          cat("  Statut inconnu\n")
        }
      }
    } else {
      cat("  Résultats non disponibles\n")
    }
  }
  
  save_asq3_results <- function() {
    output_file <- "ASQ3_PC2_GCA_Results.txt"
    
    sink(output_file, append = FALSE)
    
    cat("ANALYSE GCA PC2 AVEC MODÉRATION ASQ3\n")
    cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
    cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
    
    cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
    cat(paste(rep("-", 40), collapse = ""), "\n")
    print(summary(lmer_main))
    print(Anova(lmer_main, type = 3))
    
    cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
    cat(paste(rep("-", 40), collapse = ""), "\n")
    
    for (domain in names(asq3_results)) {
      if (!is.null(asq3_results[[domain]])) {
        cat("\nDOMAINE:", toupper(domain), "\n")
        print(asq3_results[[domain]])
      }
    }
    
    sink()
    
    cat("Résultats sauvegardés dans:", output_file, "\n")
  }
  
  save_asq3_results()

```

```{r PC3_GCA_ASQ3_Analysis}
library(dplyr)
library(car)
library(ggplot2)
library(lme4)
library(interactions)
library(emmeans)
library(ggeffects)
library(reshape2)
library(tidyr)
three_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_three.csv')
six_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_six.csv')
twelve_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_twelve.csv')

asq3_3m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/3_ASQ-4months_scores.csv')
asq3_6m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/6_ASQ-6months_scores.csv')
asq3_12m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/12_ASQ-12months_scores.csv')

print(colnames(asq3_3m))
print(colnames(asq3_6m))
print(colnames(asq3_12m))

# Fusion des données PC
merged_df <- bind_rows(
  mutate(three_df, df_source = "three", age_months = 3),
  mutate(six_df, df_source = "six", age_months = 6),
  mutate(twelve_df, df_source = "twelve", age_months = 12)
) %>%
  arrange(subject)

# convertit variable age en numérique 
merged_df$age[merged_df$age == 'three'] <- 3
merged_df$age[merged_df$age == 'six'] <- 6
merged_df$age[merged_df$age == 'twelve'] <- 12
merged_df$age <- as.numeric(merged_df$age)

# Préparation des données ASQ3
asq3_3m$age_months <- 3
asq3_6m$age_months <- 6
asq3_12m$age_months <- 12

# Fusion des données ASQ3
asq3_all <- bind_rows(asq3_3m, asq3_6m, asq3_12m) %>%
  select(subject, age_months, communication, gmotor, fmotor, pbsolving, social)

# Fusion des données PC avec ASQ3
data_combined <- merged_df %>%
  left_join(asq3_all, by = c("subject", "age_months"))

# Vérification de la fusion
cat("Nombre de lignes avant fusion:", nrow(merged_df), "\n")
cat("Nombre de lignes après fusion:", nrow(data_combined), "\n")
cat("Nombre de sujets avec données ASQ3:", sum(!is.na(data_combined$communication)), "\n")

# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC3 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC3 = mean(PC3, na.rm = TRUE),
    se_PC3 = sd(PC3, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC3, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC3 - se_PC3, ymax = mean_PC3 + se_PC3), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC3 par âge et epoch",
       x = "Âge (mois)", y = "PC3 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC3 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat(" Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC3 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC3") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat(" Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC3 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC3") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat(" Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat(" Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            # GRAPHIQUES BASÉS SUR LES PRÉDICTIONS DU MODÈLE
            # ===============================================
            
            if (length(interaction_effects) > 0) {
              cat("Création des graphiques basés sur les prédictions du modèle...\n")
              tryCatch({
                
                # ÉTAPE 1 : DÉFINIR LES NIVEAUX ASQ3 REPRÉSENTATIFS
                # ================================================
                # Utilise les percentiles pour représenter la distribution réelle
                asq3_values <- quantile(epoch_data[[asq3_domain]], 
                                        probs = c(0.25, 0.5, 0.75), 
                                        na.rm = TRUE)
                
                cat("Niveaux ASQ3 utilisés:", paste(round(asq3_values, 2), collapse = ", "), "\n")
                
                # ÉTAPE 2 : PRÉDICTIONS POUR LES EFFETS POLYNOMIAUX
                # ================================================
                
                # 2a. Effet linéaire (poly1) selon niveaux ASQ3
                pred_poly1 <- ggpredict(lmer_mod, 
                                        terms = c("poly1 [all]", 
                                                  paste0(asq3_domain, " [", 
                                                         paste(round(asq3_values, 2), collapse = ","), "]")))
                
                # 2b. Effet quadratique (poly2) selon niveaux ASQ3
                pred_poly2 <- ggpredict(lmer_mod, 
                                        terms = c("poly2 [all]", 
                                                  paste0(asq3_domain, " [", 
                                                         paste(round(asq3_values, 2), collapse = ","), "]")))
                
                # ÉTAPE 3 : PRÉPARATION DES DONNÉES POUR VISUALISATION
                # ===================================================
                
                # Convertir en data.frames et ajouter identifiants
                pred_poly1_df <- as.data.frame(pred_poly1)
                pred_poly1_df$polynomial <- "Linéaire (poly1)"
                pred_poly1_df$effect_type <- "Tendance constante"
                
                pred_poly2_df <- as.data.frame(pred_poly2)
                pred_poly2_df$polynomial <- "Quadratique (poly2)"  
                pred_poly2_df$effect_type <- "Accélération/Décélération"
                
                # Combiner les deux types d'effets
                pred_combined <- rbind(pred_poly1_df, pred_poly2_df)
                
                # Renommer les groupes pour l'affichage
                pred_combined$asq3_level <- factor(pred_combined$group,
                                                   levels = as.character(round(asq3_values, 2)),
                                                   labels = paste0(asq3_domain, " P", c(25, 50, 75)))
                
                # ÉTAPE 4 : GRAPHIQUE DES EFFETS POLYNOMIAUX
                # =========================================
                
                p_effects <- ggplot(pred_combined, aes(x = x, y = predicted)) +
                  # Intervalles de confiance
                  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = asq3_level), 
                              alpha = 0.2) +
                  # Lignes principales
                  geom_line(aes(color = asq3_level, linetype = polynomial), 
                            size = 1.3) +
                  # Séparation par type d'effet
                  facet_wrap(~effect_type, scales = "free_x") +
                  
                  labs(title = paste("Effets polynomiaux selon", asq3_domain, "- epoch:", epoch_val),
                       subtitle = "Prédictions du modèle mixte avec intervalles de confiance à 95%",
                       x = "Valeur polynomiale transformée", 
                       y = "PC3 prédit (unités standardisées)",
                       color = "Niveau ASQ3",
                       fill = "Niveau ASQ3",
                       linetype = "Composante") +
                  
                  # Esthétique
                  scale_color_brewer(type = "qual", palette = "Dark2") +
                  scale_fill_brewer(type = "qual", palette = "Dark2") +
                  scale_linetype_manual(values = c("solid", "dashed")) +
                  theme_bw() +
                  theme(
                    plot.title = element_text(size = 13, face = "bold"),
                    plot.subtitle = element_text(size = 11),
                    strip.text = element_text(size = 10, face = "bold"),
                    legend.position = "bottom",
                    legend.title = element_text(size = 10),
                    axis.text = element_text(size = 9)
                  )
                
                print(p_effects)
                cat("? Graphique des effets polynomiaux créé\n")
                
                # ÉTAPE 5 : TRAJECTOIRES DÉVELOPPEMENTALES COMPLÈTES
                # =================================================
                
                # 5a. Créer une séquence fine d'âges pour des courbes lisses
                age_range <- range(epoch_data$age, na.rm = TRUE)
                age_seq <- seq(age_range[1], age_range[2], length.out = 100)
                
                # 5b. Grille de prédiction : tous les âges × tous les niveaux ASQ3
                pred_grid <- expand.grid(
                  age = age_seq,
                  asq3_val = asq3_values
                )
                
                # 5c. Appliquer la même transformation polynomiale que le modèle original
                # CRUCIAL : Utilise exactement la même fonction que votre analyse principale
                pred_grid <- code.poly(df = pred_grid, predictor = "age", poly.order = 2, 
                                       orthogonal = TRUE, draw.poly = FALSE)
                
                # 5d. Ajouter la variable ASQ3 avec le bon nom
                pred_grid[[asq3_domain]] <- pred_grid$asq3_val
                
                # 5e. Créer les étiquettes pour l'affichage
                pred_grid$asq3_level <- factor(pred_grid$asq3_val, 
                                               levels = asq3_values,
                                               labels = paste0(asq3_domain, " P", c(25, 50, 75)))
                
                # 5f. PRÉDICTIONS DU MODÈLE (effets fixes seulement)
                pred_grid$predicted <- predict(lmer_mod, newdata = pred_grid, re.form = NA)
                
                # 5g. Calculer les intervalles de confiance (approximation)
                # Note: Pour des IC exacts, il faudrait utiliser bootMer(), mais c'est plus lent
                pred_matrix <- model.matrix(~ poly1 * get(asq3_domain) + poly2 * get(asq3_domain), 
                                            data = pred_grid)
                pred_var <- diag(pred_matrix %*% vcov(lmer_mod) %*% t(pred_matrix))
                pred_grid$se <- sqrt(pred_var)
                pred_grid$conf_low <- pred_grid$predicted - 1.96 * pred_grid$se
                pred_grid$conf_high <- pred_grid$predicted + 1.96 * pred_grid$se
                
                # ÉTAPE 6 : GRAPHIQUE DES TRAJECTOIRES DÉVELOPPEMENTALES
                # =====================================================
                
                # 6a. Préparer les données observées avec classification ASQ3
                epoch_data$asq3_quartile <- cut(epoch_data[[asq3_domain]], 
                                                breaks = c(-Inf, asq3_values, Inf),
                                                labels = c("< P25", "P25-P50", "P50-P75", "> P75"),
                                                include.lowest = TRUE)
                
                # 6b. Créer le graphique principal
                p_trajectories <- ggplot() +
                  
                  # Intervalles de confiance des prédictions
                  geom_ribbon(data = pred_grid,
                              aes(x = age, ymin = conf_low, ymax = conf_high, fill = asq3_level),
                              alpha = 0.2) +
                  
                  # Trajectoires prédites (lignes principales)
                  geom_line(data = pred_grid,
                            aes(x = age, y = predicted, color = asq3_level),
                            size = 2, alpha = 0.9) +
                  
                  # Points observés (données réelles)
                  geom_point(data = epoch_data[!is.na(epoch_data$asq3_quartile), ],
                             aes(x = age, y = PC3, color = asq3_quartile),
                             alpha = 0.6, size = 2, shape = 16) +
                  
                  # Moyennes observées par âge et niveau ASQ3
                  stat_summary(data = epoch_data[!is.na(epoch_data$asq3_quartile), ],
                               aes(x = age, y = PC3, color = asq3_quartile),
                               fun = mean, geom = "point", size = 4, shape = 17, alpha = 0.8) +
                  
                  # Esthétique et labels
                  labs(title = paste("Trajectoires développementales de PC3 selon", asq3_domain),
                       subtitle = paste("Epoch:", epoch_val, "? Lignes = prédictions du modèle ? Points = données observées ? Triangles = moyennes"),
                       x = "Âge (mois)", 
                       y = "PC3 (score standardisé)",
                       color = paste("Niveau", asq3_domain),
                       fill = paste("Niveau", asq3_domain)) +
                  
                  # Couleurs et thème
                  scale_color_brewer(type = "qual", palette = "Set1") +
                  scale_fill_brewer(type = "qual", palette = "Set1") +
                  scale_x_continuous(breaks = unique(epoch_data$age)) +
                  theme_bw() +
                  theme(
                    plot.title = element_text(size = 14, face = "bold"),
                    plot.subtitle = element_text(size = 11),
                    legend.position = "bottom",
                    legend.title = element_text(size = 11, face = "bold"),
                    legend.text = element_text(size = 10),
                    axis.title = element_text(size = 12),
                    axis.text = element_text(size = 10),
                    panel.grid.minor = element_blank()
                  ) +
                  
                  # Guides pour améliorer la légende
                  guides(
                    color = guide_legend(override.aes = list(size = 3, alpha = 1)),
                    fill = guide_legend(override.aes = list(alpha = 0.3))
                  )
                
                print(p_trajectories)
                cat("? Graphique des trajectoires développementales créé\n")
                
                # ÉTAPE 7 : STATISTIQUES DESCRIPTIVES POUR INTERPRÉTATION
                # ======================================================
                
                cat("\n--- STATISTIQUES POUR INTERPRÉTATION ---\n")
                
                # Différences entre niveaux ASQ3 à chaque âge
                age_effects <- pred_grid %>%
                  select(age, asq3_level, predicted) %>%
                  pivot_wider(names_from = asq3_level, values_from = predicted) %>%
                  mutate(
                    diff_P75_P25 = get(paste0(asq3_domain, " P75")) - get(paste0(asq3_domain, " P25")),
                    diff_P50_P25 = get(paste0(asq3_domain, " P50")) - get(paste0(asq3_domain, " P25"))
                  )
                
                cat("Différences prédites entre niveaux ASQ3 :\n")
                cat("À 3 mois - P75 vs P25:", round(age_effects$diff_P75_P25[1], 3), "\n")
                cat("À 12 mois - P75 vs P25:", round(age_effects$diff_P75_P25[nrow(age_effects)], 3), "\n")
                
                # Pentes développementales par groupe
                slopes <- pred_grid %>%
                  group_by(asq3_level) %>%
                  do(model = lm(predicted ~ age, data = .)) %>%
                  mutate(slope = map_dbl(model, ~ coef(.)[2]))
                
                cat("Pentes développementales (changement par mois) :\n")
                for(i in 1:nrow(slopes)) {
                  cat("-", slopes$asq3_level[i], ":", round(slopes$slope[i], 4), "\n")
                }
                
                cat("? Graphiques basés sur le modèle créés avec succès\n")
                
              }, error = function(e) {
                cat("? Erreur dans les graphiques basés sur le modèle:", e$message, "\n")
                cat("Détails:", paste(e$call, collapse = " "), "\n")
              })
            }
          }
          )
        }
      }
    }
  }
  
  # Exécuter le diagnostic avant l'analyse
  diagnose_data()
  
  # Exécuter l'analyse corrigée pour chaque domaine ASQ3
  cat("\n", paste(rep("=", 80), collapse = ""), "\n")
  cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
  cat(paste(rep("=", 80), collapse = ""), "\n")
  
  asq3_results_corrected <- list()
  
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n Traitement du domaine:", domain, "\n")
      results <- analyze_asq3_moderator(domain)
      asq3_results_corrected[[domain]] <- results
    } else {
      cat(" ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
    }
  }
  
  # Résumé final amélioré
  cat("\n", paste(rep("=", 80), collapse = ""), "\n")
  cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
  cat(paste(rep("=", 80), collapse = ""), "\n")
  
  for (domain in names(asq3_results_corrected)) {
    cat("\n DOMAINE:", toupper(domain), "\n")
    cat(paste(rep("-", 40), collapse = ""), "\n")
    
    domain_results <- asq3_results_corrected[[domain]]
    
    if (is.list(domain_results) && !is.null(names(domain_results))) {
      for (epoch_name in names(domain_results)) {
        epoch_result <- domain_results[[epoch_name]]
        cat(" Epoch", epoch_name, ":")
        
        if ("model" %in% names(epoch_result)) {
          n_sig <- length(epoch_result$significance$significant_effects)
          cat("  Analysée (", n_sig, " effets significatifs)\n")
        } else if ("error" %in% names(epoch_result)) {
          cat(" ? Erreur:", epoch_result$error, "\n")
        } else if ("issue" %in% names(epoch_result)) {
          cat("  Problème:", epoch_result$issue, "\n")
        } else {
          cat("  Statut inconnu\n")
        }
      }
    } else {
      cat("  Résultats non disponibles\n")
    }
  }
  
  save_asq3_results <- function() {
    output_file <- "ASQ3_PC3_GCA_Results.txt"
    
    sink(output_file, append = FALSE)
    
    cat("ANALYSE GCA PC3 AVEC MODÉRATION ASQ3\n")
    cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
    cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
    
    cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
    cat(paste(rep("-", 40), collapse = ""), "\n")
    print(summary(lmer_main))
    print(Anova(lmer_main, type = 3))
    
    cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
    cat(paste(rep("-", 40), collapse = ""), "\n")
    
    for (domain in names(asq3_results)) {
      if (!is.null(asq3_results[[domain]])) {
        cat("\nDOMAINE:", toupper(domain), "\n")
        print(asq3_results[[domain]])
      }
    }
    
    sink()
    
    cat("Résultats sauvegardés dans:", output_file, "\n")
  }
  
  save_asq3_results()
  
```
  
  

```{r PC4_GCA_ASQ3_Analysis}
# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}
    
# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC4 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC4 = mean(PC4, na.rm = TRUE),
    se_PC4 = sd(PC4, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC4, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC4 - se_PC4, ymax = mean_PC4 + se_PC4), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC4 par âge et epoch",
       x = "Âge (mois)", y = "PC4 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC4 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat("Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC4 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC4") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat("Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC4 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC4") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat("Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
            # Graphique d'interaction simple
            if (length(interaction_effects) > 0) {
              cat("Création du graphique d'interaction...\n")
              tryCatch({
                # Créer des niveaux de la variable ASQ3 pour la visualisation
                epoch_data$asq3_level <- cut(epoch_data[[asq3_domain]], 
                                             breaks = 3, 
                                             labels = c("Faible", "Moyen", "Élevé"))
                
                p_interaction <- ggplot(epoch_data, aes(x = age, y = PC4, color = asq3_level)) +
                  geom_smooth(method = "loess", se = TRUE) +
                  geom_point(alpha = 0.5) +
                  labs(title = paste("Interaction Age ×", asq3_domain, "- epoch:", epoch_val),
                       x = "Âge (mois)", y = "PC4",
                       color = paste("Niveau", asq3_domain)) +
                  theme_bw()
                
                print(p_interaction)
                cat("Graphique d'interaction créé\n")
                
              }, error = function(e) {
                cat("Erreur graphique interaction:", e$message, "\n")
              })
            }
            
          }, error = function(e) {
            cat("Erreur modèle pour epoch", epoch_val, ":", e$message, "\n")
            epoch_results[[epoch_val]] <- list(
              error = e$message,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data)
            )
          })
          
        } else {
          cat("Variable ASQ3 pas assez variable pour cette epoch (", length(unique_values), " valeurs uniques)\n")
          epoch_results[[epoch_val]] <- list(
            issue = "insufficient_variability",
            epoch = epoch_val,
            domain = asq3_domain,
            n_obs = nrow(epoch_data)
          )
        }
        
      } else {
        cat("Données insuffisantes pour epoch", epoch_val, "(n =", nrow(epoch_data), ")\n")
        epoch_results[[epoch_val]] <- list(
          issue = "insufficient_data",
          epoch = epoch_val,
          domain = asq3_domain,
          n_obs = nrow(epoch_data)
        )
      }
    }
    
    return(epoch_results)
    
  } else {
    cat(" Données insuffisantes globalement (n =", nrow(subset_data), ")\n")
    return(list(global_issue = "insufficient_data", n_obs = nrow(subset_data)))
  }
}

diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat("ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}

# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat("  epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat("  Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("Statut inconnu\n")
      }
    }
  } else {
    cat("Résultats non disponibles\n")
  }
}


# Fonction pour sauvegarder tous les résultats
save_asq3_results <- function() {
  output_file <- "ASQ3_PC4_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC4 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

# Sauvegarder les résultats
save_asq3_results()

```

```{r PC5_GCA_ASQ3_Analysis}

# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC5 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC5 = mean(PC5, na.rm = TRUE),
    se_PC5 = sd(PC5, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC5, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC5 - se_PC5, ymax = mean_PC5 + se_PC5), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC5 par âge et epoch",
       x = "Âge (mois)", y = "PC5 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC5 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat("Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC5 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC5") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat("Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC5 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC5") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat("Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
            # Graphique d'interaction simple
            if (length(interaction_effects) > 0) {
              cat("Création du graphique d'interaction...\n")
              tryCatch({
                # Créer des niveaux de la variable ASQ3 pour la visualisation
                epoch_data$asq3_level <- cut(epoch_data[[asq3_domain]], 
                                             breaks = 3, 
                                             labels = c("Faible", "Moyen", "Élevé"))
                
                p_interaction <- ggplot(epoch_data, aes(x = age, y = PC5, color = asq3_level)) +
                  geom_smooth(method = "loess", se = TRUE) +
                  geom_point(alpha = 0.5) +
                  labs(title = paste("Interaction Age ×", asq3_domain, "- epoch:", epoch_val),
                       x = "Âge (mois)", y = "PC5",
                       color = paste("Niveau", asq3_domain)) +
                  theme_bw()
                
                print(p_interaction)
                cat("Graphique d'interaction créé\n")
                
              }, error = function(e) {
                cat("Erreur graphique interaction:", e$message, "\n")
              })
            }
            
          }, error = function(e) {
            cat("Erreur modèle pour epoch", epoch_val, ":", e$message, "\n")
            epoch_results[[epoch_val]] <- list(
              error = e$message,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data)
            )
          })
          
        } else {
          cat("Variable ASQ3 pas assez variable pour cette epoch (", length(unique_values), " valeurs uniques)\n")
          epoch_results[[epoch_val]] <- list(
            issue = "insufficient_variability",
            epoch = epoch_val,
            domain = asq3_domain,
            n_obs = nrow(epoch_data)
          )
        }
        
      } else {
        cat("Données insuffisantes pour epoch", epoch_val, "(n =", nrow(epoch_data), ")\n")
        epoch_results[[epoch_val]] <- list(
          issue = "insufficient_data",
          epoch = epoch_val,
          domain = asq3_domain,
          n_obs = nrow(epoch_data)
        )
      }
    }
    
    return(epoch_results)
    
  } else {
    cat(" Données insuffisantes globalement (n =", nrow(subset_data), ")\n")
    return(list(global_issue = "insufficient_data", n_obs = nrow(subset_data)))
  }
}


# Exécuter le diagnostic avant l'analyse
diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat("ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}

# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat("  epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat("  Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("Statut inconnu\n")
      }
    }
  } else {
    cat("Résultats non disponibles\n")
  }
}


# Fonction pour sauvegarder tous les résultats
save_asq3_results <- function() {
  output_file <- "ASQ3_PC5_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC5 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

# Sauvegarder les résultats
save_asq3_results()

```



```{r PC6_GCA_ASQ3_Analysis}


# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC6 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC6 = mean(PC6, na.rm = TRUE),
    se_PC6 = sd(PC6, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC6, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC6 - se_PC6, ymax = mean_PC6 + se_PC6), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC6 par âge et epoch",
       x = "Âge (mois)", y = "PC6 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC6 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat("Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC6 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC6") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat("Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC6 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC6") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat("Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
            # Graphique d'interaction simple
            if (length(interaction_effects) > 0) {
              cat("Création du graphique d'interaction...\n")
              tryCatch({
                # Créer des niveaux de la variable ASQ3 pour la visualisation
                epoch_data$asq3_level <- cut(epoch_data[[asq3_domain]], 
                                             breaks = 3, 
                                             labels = c("Faible", "Moyen", "Élevé"))
                
                p_interaction <- ggplot(epoch_data, aes(x = age, y = PC6, color = asq3_level)) +
                  geom_smooth(method = "loess", se = TRUE) +
                  geom_point(alpha = 0.5) +
                  labs(title = paste("Interaction Age ×", asq3_domain, "- epoch:", epoch_val),
                       x = "Âge (mois)", y = "PC6",
                       color = paste("Niveau", asq3_domain)) +
                  theme_bw()
                
                print(p_interaction)
                cat("Graphique d'interaction créé\n")
                
              }, error = function(e) {
                cat("Erreur graphique interaction:", e$message, "\n")
              })
            }
            
          }, error = function(e) {
            cat("Erreur modèle pour epoch", epoch_val, ":", e$message, "\n")
            epoch_results[[epoch_val]] <- list(
              error = e$message,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data)
            )
          })
          
        } else {
          cat("Variable ASQ3 pas assez variable pour cette epoch (", length(unique_values), " valeurs uniques)\n")
          epoch_results[[epoch_val]] <- list(
            issue = "insufficient_variability",
            epoch = epoch_val,
            domain = asq3_domain,
            n_obs = nrow(epoch_data)
          )
        }
        
      } else {
        cat("Données insuffisantes pour epoch", epoch_val, "(n =", nrow(epoch_data), ")\n")
        epoch_results[[epoch_val]] <- list(
          issue = "insufficient_data",
          epoch = epoch_val,
          domain = asq3_domain,
          n_obs = nrow(epoch_data)
        )
      }
    }
    
    # RETOURNER TOUS LES RÉSULTATS D'epoch
    return(epoch_results)
    
  } else {
    cat(" Données insuffisantes globalement (n =", nrow(subset_data), ")\n")
    return(list(global_issue = "insufficient_data", n_obs = nrow(subset_data)))
  }
}


# Exécuter le diagnostic avant l'analyse
diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat("ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}


# Résumé final amélioré
cat("\n", strrep("=", 80), "\n")
cat("Resume\n")
cat(strrep("=", 80), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\nDOMAINE :", toupper(domain), "\n")
  cat(strrep("-", 40), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat("  Epoch", epoch_name, ":")
      
      if (!is.null(epoch_result$model)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effet(s) significatif(s))\n")
      } else if (!is.null(epoch_result$error)) {
        cat("  Erreur :", epoch_result$error, "\n")
      } else if (!is.null(epoch_result$issue)) {
        cat("  Problème :", epoch_result$issue, "\n")
      } else {
        cat("  Statut inconnu\n")
      }
    }
  } else {
    cat("  Résultats non disponibles\n")
  }
}



# Fonction pour sauvegarder tous les résultats
save_asq3_results <- function() {
  output_file <- "ASQ3_PC6_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC6 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

# Sauvegarder les résultats
save_asq3_results()

```


```{r PC8_GCA_ASQ3_Analysis}

# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC8 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC8 = mean(PC8, na.rm = TRUE),
    se_PC8 = sd(PC8, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC8, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC8 - se_PC8, ymax = mean_PC8 + se_PC8), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC8 par âge et epoch",
       x = "Âge (mois)", y = "PC8 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC8 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat("Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC8 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC8") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat("Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC8 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC8") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat("Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
            # Graphique d'interaction simple
            if (length(interaction_effects) > 0) {
              cat("Création du graphique d'interaction...\n")
              tryCatch({
                # Créer des niveaux de la variable ASQ3 pour la visualisation
                epoch_data$asq3_level <- cut(epoch_data[[asq3_domain]], 
                                             breaks = 3, 
                                             labels = c("Faible", "Moyen", "Élevé"))
                
                p_interaction <- ggplot(epoch_data, aes(x = age, y = PC8, color = asq3_level)) +
                  geom_smooth(method = "loess", se = TRUE) +
                  geom_point(alpha = 0.5) +
                  labs(title = paste("Interaction Age ×", asq3_domain, "- epoch:", epoch_val),
                       x = "Âge (mois)", y = "PC8",
                       color = paste("Niveau", asq3_domain)) +
                  theme_bw()
                
                print(p_interaction)
                cat("Graphique d'interaction créé\n")
                
              }, error = function(e) {
                cat("Erreur graphique interaction:", e$message, "\n")
              })
            }
            
          }, error = function(e) {
            cat("Erreur modèle pour epoch", epoch_val, ":", e$message, "\n")
            epoch_results[[epoch_val]] <- list(
              error = e$message,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data)
            )
          })
          
        } else {
          cat("Variable ASQ3 pas assez variable pour cette epoch (", length(unique_values), " valeurs uniques)\n")
          epoch_results[[epoch_val]] <- list(
            issue = "insufficient_variability",
            epoch = epoch_val,
            domain = asq3_domain,
            n_obs = nrow(epoch_data)
          )
        }
        
      } else {
        cat("Données insuffisantes pour epoch", epoch_val, "(n =", nrow(epoch_data), ")\n")
        epoch_results[[epoch_val]] <- list(
          issue = "insufficient_data",
          epoch = epoch_val,
          domain = asq3_domain,
          n_obs = nrow(epoch_data)
        )
      }
    }
    
    # RETOURNER TOUS LES RÉSULTATS D'epoch
    return(epoch_results)
    
  } else {
    cat(" Données insuffisantes globalement (n =", nrow(subset_data), ")\n")
    return(list(global_issue = "insufficient_data", n_obs = nrow(subset_data)))
  }
}


# Exécuter le diagnostic avant l'analyse
diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat("ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}


# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat("  epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat("  Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("Statut inconnu\n")
      }
    }
  } else {
    cat("Résultats non disponibles\n")
  }
}


# Fonction pour sauvegarder tous les résultats
save_asq3_results <- function() {
  output_file <- "ASQ3_PC8_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC8 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

# Sauvegarder les résultats
save_asq3_results()

```


```{r PC9_GCA_ASQ3_Analysis}


# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC9 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC9 = mean(PC9, na.rm = TRUE),
    se_PC9 = sd(PC9, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC9, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC9 - se_PC9, ymax = mean_PC9 + se_PC9), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC9 par âge et epoch",
       x = "Âge (mois)", y = "PC9 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC9 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat("Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC9 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC9") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat("Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC9 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC9") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat("Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
            # Graphique d'interaction simple
            if (length(interaction_effects) > 0) {
              cat("Création du graphique d'interaction...\n")
              tryCatch({
                # Créer des niveaux de la variable ASQ3 pour la visualisation
                epoch_data$asq3_level <- cut(epoch_data[[asq3_domain]], 
                                             breaks = 3, 
                                             labels = c("Faible", "Moyen", "Élevé"))
                
                p_interaction <- ggplot(epoch_data, aes(x = age, y = PC9, color = asq3_level)) +
                  geom_smooth(method = "loess", se = TRUE) +
                  geom_point(alpha = 0.5) +
                  labs(title = paste("Interaction Age ×", asq3_domain, "- epoch:", epoch_val),
                       x = "Âge (mois)", y = "PC9",
                       color = paste("Niveau", asq3_domain)) +
                  theme_bw()
                
                print(p_interaction)
                cat("Graphique d'interaction créé\n")
                
              }, error = function(e) {
                cat("Erreur graphique interaction:", e$message, "\n")
              })
            }
            
          }, error = function(e) {
            cat("Erreur modèle pour epoch", epoch_val, ":", e$message, "\n")
            epoch_results[[epoch_val]] <- list(
              error = e$message,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data)
            )
          })
          
        } else {
          cat("Variable ASQ3 pas assez variable pour cette epoch (", length(unique_values), " valeurs uniques)\n")
          epoch_results[[epoch_val]] <- list(
            issue = "insufficient_variability",
            epoch = epoch_val,
            domain = asq3_domain,
            n_obs = nrow(epoch_data)
          )
        }
        
      } else {
        cat("Données insuffisantes pour epoch", epoch_val, "(n =", nrow(epoch_data), ")\n")
        epoch_results[[epoch_val]] <- list(
          issue = "insufficient_data",
          epoch = epoch_val,
          domain = asq3_domain,
          n_obs = nrow(epoch_data)
        )
      }
    }
    
    # RETOURNER TOUS LES RÉSULTATS D'epoch
    return(epoch_results)
    
  } else {
    cat(" Données insuffisantes globalement (n =", nrow(subset_data), ")\n")
    return(list(global_issue = "insufficient_data", n_obs = nrow(subset_data)))
  }
}


# Exécuter le diagnostic avant l'analyse
diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat("ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}


# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat("  epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat("  Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("Statut inconnu\n")
      }
    }
  } else {
    cat("Résultats non disponibles\n")
  }
}


# Fonction pour sauvegarder tous les résultats
save_asq3_results <- function() {
  output_file <- "ASQ3_PC9_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC9 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

# Sauvegarder les résultats
save_asq3_results()

```


```{r PC10_GCA_ASQ3_Analysis}

# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC10 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC10 = mean(PC10, na.rm = TRUE),
    se_PC10 = sd(PC10, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC10, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC10 - se_PC10, ymax = mean_PC10 + se_PC10), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC10 par âge et epoch",
       x = "Âge (mois)", y = "PC10 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC10 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat("Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC10 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC10") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat("Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC10 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC10") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat("Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
            # Graphique d'interaction simple
            if (length(interaction_effects) > 0) {
              cat("Création du graphique d'interaction...\n")
              tryCatch({
                # Créer des niveaux de la variable ASQ3 pour la visualisation
                epoch_data$asq3_level <- cut(epoch_data[[asq3_domain]], 
                                             breaks = 3, 
                                             labels = c("Faible", "Moyen", "Élevé"))
                
                p_interaction <- ggplot(epoch_data, aes(x = age, y = PC10, color = asq3_level)) +
                  geom_smooth(method = "loess", se = TRUE) +
                  geom_point(alpha = 0.5) +
                  labs(title = paste("Interaction Age ×", asq3_domain, "- epoch:", epoch_val),
                       x = "Âge (mois)", y = "PC10",
                       color = paste("Niveau", asq3_domain)) +
                  theme_bw()
                
                print(p_interaction)
                cat("Graphique d'interaction créé\n")
                
              }, error = function(e) {
                cat("Erreur graphique interaction:", e$message, "\n")
              })
            }
            
          }, error = function(e) {
            cat("Erreur modèle pour epoch", epoch_val, ":", e$message, "\n")
            epoch_results[[epoch_val]] <- list(
              error = e$message,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data)
            )
          })
          
        } else {
          cat("Variable ASQ3 pas assez variable pour cette epoch (", length(unique_values), " valeurs uniques)\n")
          epoch_results[[epoch_val]] <- list(
            issue = "insufficient_variability",
            epoch = epoch_val,
            domain = asq3_domain,
            n_obs = nrow(epoch_data)
          )
        }
        
      } else {
        cat("Données insuffisantes pour epoch", epoch_val, "(n =", nrow(epoch_data), ")\n")
        epoch_results[[epoch_val]] <- list(
          issue = "insufficient_data",
          epoch = epoch_val,
          domain = asq3_domain,
          n_obs = nrow(epoch_data)
        )
      }
    }
    
    # RETOURNER TOUS LES RÉSULTATS D'epoch
    return(epoch_results)
    
  } else {
    cat(" Données insuffisantes globalement (n =", nrow(subset_data), ")\n")
    return(list(global_issue = "insufficient_data", n_obs = nrow(subset_data)))
  }
}


# Exécuter le diagnostic avant l'analyse
diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat("ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}


# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat("  epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat("  Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("Statut inconnu\n")
      }
    }
  } else {
    cat("Résultats non disponibles\n")
  }
}


# Fonction pour sauvegarder tous les résultats
save_asq3_results <- function() {
  output_file <- "ASQ3_PC10_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC10 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

# Sauvegarder les résultats
save_asq3_results()

```


```{r PC11_GCA_ASQ3_Analysis}

# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC11 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC11 = mean(PC11, na.rm = TRUE),
    se_PC11 = sd(PC11, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC11, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC11 - se_PC11, ymax = mean_PC11 + se_PC11), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC11 par âge et epoch",
       x = "Âge (mois)", y = "PC11 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC11 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat("Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC11 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC11") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat("Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC11 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC11") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat("Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
            # Graphique d'interaction simple
            if (length(interaction_effects) > 0) {
              cat("Création du graphique d'interaction...\n")
              tryCatch({
                # Créer des niveaux de la variable ASQ3 pour la visualisation
                epoch_data$asq3_level <- cut(epoch_data[[asq3_domain]], 
                                             breaks = 3, 
                                             labels = c("Faible", "Moyen", "Élevé"))
                
                p_interaction <- ggplot(epoch_data, aes(x = age, y = PC11, color = asq3_level)) +
                  geom_smooth(method = "loess", se = TRUE) +
                  geom_point(alpha = 0.5) +
                  labs(title = paste("Interaction Age ×", asq3_domain, "- epoch:", epoch_val),
                       x = "Âge (mois)", y = "PC11",
                       color = paste("Niveau", asq3_domain)) +
                  theme_bw()
                
                print(p_interaction)
                cat("Graphique d'interaction créé\n")
                
              }, error = function(e) {
                cat("Erreur graphique interaction:", e$message, "\n")
              })
            }
            
          }, error = function(e) {
            cat("Erreur modèle pour epoch", epoch_val, ":", e$message, "\n")
            epoch_results[[epoch_val]] <- list(
              error = e$message,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data)
            )
          })
          
        } else {
          cat("Variable ASQ3 pas assez variable pour cette epoch (", length(unique_values), " valeurs uniques)\n")
          epoch_results[[epoch_val]] <- list(
            issue = "insufficient_variability",
            epoch = epoch_val,
            domain = asq3_domain,
            n_obs = nrow(epoch_data)
          )
        }
        
      } else {
        cat("Données insuffisantes pour epoch", epoch_val, "(n =", nrow(epoch_data), ")\n")
        epoch_results[[epoch_val]] <- list(
          issue = "insufficient_data",
          epoch = epoch_val,
          domain = asq3_domain,
          n_obs = nrow(epoch_data)
        )
      }
    }
    
    # RETOURNER TOUS LES RÉSULTATS D'epoch
    return(epoch_results)
    
  } else {
    cat(" Données insuffisantes globalement (n =", nrow(subset_data), ")\n")
    return(list(global_issue = "insufficient_data", n_obs = nrow(subset_data)))
  }
}


# Exécuter le diagnostic avant l'analyse
diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat("ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}


# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat("  epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat("  Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("Statut inconnu\n")
      }
    }
  } else {
    cat("Résultats non disponibles\n")
  }
}


# Fonction pour sauvegarder tous les résultats
save_asq3_results <- function() {
  output_file <- "ASQ3_PC11_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC11 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

# Sauvegarder les résultats
save_asq3_results()

```


```{r PC12_GCA_ASQ3_Analysis}

# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC12 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC12 = mean(PC12, na.rm = TRUE),
    se_PC12 = sd(PC12, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC12, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC12 - se_PC12, ymax = mean_PC12 + se_PC12), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC12 par âge et epoch",
       x = "Âge (mois)", y = "PC12 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC12 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat("Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC12 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC12") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat("Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC12 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC12") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat("Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
            # Graphique d'interaction simple
            if (length(interaction_effects) > 0) {
              cat("Création du graphique d'interaction...\n")
              tryCatch({
                # Créer des niveaux de la variable ASQ3 pour la visualisation
                epoch_data$asq3_level <- cut(epoch_data[[asq3_domain]], 
                                             breaks = 3, 
                                             labels = c("Faible", "Moyen", "Élevé"))
                
                p_interaction <- ggplot(epoch_data, aes(x = age, y = PC12, color = asq3_level)) +
                  geom_smooth(method = "loess", se = TRUE) +
                  geom_point(alpha = 0.5) +
                  labs(title = paste("Interaction Age ×", asq3_domain, "- epoch:", epoch_val),
                       x = "Âge (mois)", y = "PC12",
                       color = paste("Niveau", asq3_domain)) +
                  theme_bw()
                
                print(p_interaction)
                cat("Graphique d'interaction créé\n")
                
              }, error = function(e) {
                cat("Erreur graphique interaction:", e$message, "\n")
              })
            }
            
          }, error = function(e) {
            cat("Erreur modèle pour epoch", epoch_val, ":", e$message, "\n")
            epoch_results[[epoch_val]] <- list(
              error = e$message,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data)
            )
          })
          
        } else {
          cat("Variable ASQ3 pas assez variable pour cette epoch (", length(unique_values), " valeurs uniques)\n")
          epoch_results[[epoch_val]] <- list(
            issue = "insufficient_variability",
            epoch = epoch_val,
            domain = asq3_domain,
            n_obs = nrow(epoch_data)
          )
        }
        
      } else {
        cat("Données insuffisantes pour epoch", epoch_val, "(n =", nrow(epoch_data), ")\n")
        epoch_results[[epoch_val]] <- list(
          issue = "insufficient_data",
          epoch = epoch_val,
          domain = asq3_domain,
          n_obs = nrow(epoch_data)
        )
      }
    }
    
    # RETOURNER TOUS LES RÉSULTATS D'epoch
    return(epoch_results)
    
  } else {
    cat(" Données insuffisantes globalement (n =", nrow(subset_data), ")\n")
    return(list(global_issue = "insufficient_data", n_obs = nrow(subset_data)))
  }
}


# Exécuter le diagnostic avant l'analyse
diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat("ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}


# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat("  epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat("  Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("Statut inconnu\n")
      }
    }
  } else {
    cat("Résultats non disponibles\n")
  }
}


# Fonction pour sauvegarder tous les résultats
save_asq3_results <- function() {
  output_file <- "ASQ3_PC12_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC12 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

# Sauvegarder les résultats
save_asq3_results()

```


```{r PC13_GCA_ASQ3_Analysis}

# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC13 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC13 = mean(PC13, na.rm = TRUE),
    se_PC13 = sd(PC13, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC13, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC13 - se_PC13, ymax = mean_PC13 + se_PC13), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC13 par âge et epoch",
       x = "Âge (mois)", y = "PC13 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC13 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat("Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC13 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC13") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat("Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC13 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC13") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat("Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
            # Graphique d'interaction simple
            if (length(interaction_effects) > 0) {
              cat("Création du graphique d'interaction...\n")
              tryCatch({
                # Créer des niveaux de la variable ASQ3 pour la visualisation
                epoch_data$asq3_level <- cut(epoch_data[[asq3_domain]], 
                                             breaks = 3, 
                                             labels = c("Faible", "Moyen", "Élevé"))
                
                p_interaction <- ggplot(epoch_data, aes(x = age, y = PC13, color = asq3_level)) +
                  geom_smooth(method = "loess", se = TRUE) +
                  geom_point(alpha = 0.5) +
                  labs(title = paste("Interaction Age ×", asq3_domain, "- epoch:", epoch_val),
                       x = "Âge (mois)", y = "PC13",
                       color = paste("Niveau", asq3_domain)) +
                  theme_bw()
                
                print(p_interaction)
                cat("Graphique d'interaction créé\n")
                
              }, error = function(e) {
                cat("Erreur graphique interaction:", e$message, "\n")
              })
            }
            
          }, error = function(e) {
            cat("Erreur modèle pour epoch", epoch_val, ":", e$message, "\n")
            epoch_results[[epoch_val]] <- list(
              error = e$message,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data)
            )
          })
          
        } else {
          cat("Variable ASQ3 pas assez variable pour cette epoch (", length(unique_values), " valeurs uniques)\n")
          epoch_results[[epoch_val]] <- list(
            issue = "insufficient_variability",
            epoch = epoch_val,
            domain = asq3_domain,
            n_obs = nrow(epoch_data)
          )
        }
        
      } else {
        cat("Données insuffisantes pour epoch", epoch_val, "(n =", nrow(epoch_data), ")\n")
        epoch_results[[epoch_val]] <- list(
          issue = "insufficient_data",
          epoch = epoch_val,
          domain = asq3_domain,
          n_obs = nrow(epoch_data)
        )
      }
    }
    
    # RETOURNER TOUS LES RÉSULTATS D'epoch
    return(epoch_results)
    
  } else {
    cat(" Données insuffisantes globalement (n =", nrow(subset_data), ")\n")
    return(list(global_issue = "insufficient_data", n_obs = nrow(subset_data)))
  }
}


# Exécuter le diagnostic avant l'analyse
diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat("ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}


# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat("  epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat("  Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("Statut inconnu\n")
      }
    }
  } else {
    cat("Résultats non disponibles\n")
  }
}


# Fonction pour sauvegarder tous les résultats
save_asq3_results <- function() {
  output_file <- "ASQ3_PC13_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC13 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

# Sauvegarder les résultats
save_asq3_results()

```

```{r PC14_GCA_ASQ3_Analysis}

# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC14 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC14 = mean(PC14, na.rm = TRUE),
    se_PC14 = sd(PC14, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC14, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC14 - se_PC14, ymax = mean_PC14 + se_PC14), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC14 par âge et epoch",
       x = "Âge (mois)", y = "PC14 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC14 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat("Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC14 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC14") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat("Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC14 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC14") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat("Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
            # Graphique d'interaction simple
            if (length(interaction_effects) > 0) {
              cat("Création du graphique d'interaction...\n")
              tryCatch({
                # Créer des niveaux de la variable ASQ3 pour la visualisation
                epoch_data$asq3_level <- cut(epoch_data[[asq3_domain]], 
                                             breaks = 3, 
                                             labels = c("Faible", "Moyen", "Élevé"))
                
                p_interaction <- ggplot(epoch_data, aes(x = age, y = PC14, color = asq3_level)) +
                  geom_smooth(method = "loess", se = TRUE) +
                  geom_point(alpha = 0.5) +
                  labs(title = paste("Interaction Age ×", asq3_domain, "- epoch:", epoch_val),
                       x = "Âge (mois)", y = "PC14",
                       color = paste("Niveau", asq3_domain)) +
                  theme_bw()
                
                print(p_interaction)
                cat("Graphique d'interaction créé\n")
                
              }, error = function(e) {
                cat("Erreur graphique interaction:", e$message, "\n")
              })
            }
            
          }, error = function(e) {
            cat("Erreur modèle pour epoch", epoch_val, ":", e$message, "\n")
            epoch_results[[epoch_val]] <- list(
              error = e$message,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data)
            )
          })
          
        } else {
          cat("Variable ASQ3 pas assez variable pour cette epoch (", length(unique_values), " valeurs uniques)\n")
          epoch_results[[epoch_val]] <- list(
            issue = "insufficient_variability",
            epoch = epoch_val,
            domain = asq3_domain,
            n_obs = nrow(epoch_data)
          )
        }
        
      } else {
        cat("Données insuffisantes pour epoch", epoch_val, "(n =", nrow(epoch_data), ")\n")
        epoch_results[[epoch_val]] <- list(
          issue = "insufficient_data",
          epoch = epoch_val,
          domain = asq3_domain,
          n_obs = nrow(epoch_data)
        )
      }
    }
    
    # RETOURNER TOUS LES RÉSULTATS D'epoch
    return(epoch_results)
    
  } else {
    cat(" Données insuffisantes globalement (n =", nrow(subset_data), ")\n")
    return(list(global_issue = "insufficient_data", n_obs = nrow(subset_data)))
  }
}


# Exécuter le diagnostic avant l'analyse
diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat("ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}


# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat("  epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat("  Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("Statut inconnu\n")
      }
    }
  } else {
    cat("Résultats non disponibles\n")
  }
}


# Fonction pour sauvegarder tous les résultats
save_asq3_results <- function() {
  output_file <- "ASQ3_PC14_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC14 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

# Sauvegarder les résultats
save_asq3_results()

```

```{r PC15_GCA_ASQ3_Analysis}


# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC15 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC15 = mean(PC15, na.rm = TRUE),
    se_PC15 = sd(PC15, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC15, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC15 - se_PC15, ymax = mean_PC15 + se_PC15), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC15 par âge et epoch",
       x = "Âge (mois)", y = "PC15 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC15 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat("Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC15 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC15") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat("Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC15 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC15") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat("Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
            # Graphique d'interaction simple
            if (length(interaction_effects) > 0) {
              cat("Création du graphique d'interaction...\n")
              tryCatch({
                # Créer des niveaux de la variable ASQ3 pour la visualisation
                epoch_data$asq3_level <- cut(epoch_data[[asq3_domain]], 
                                             breaks = 3, 
                                             labels = c("Faible", "Moyen", "Élevé"))
                
                p_interaction <- ggplot(epoch_data, aes(x = age, y = PC15, color = asq3_level)) +
                  geom_smooth(method = "loess", se = TRUE) +
                  geom_point(alpha = 0.5) +
                  labs(title = paste("Interaction Age ×", asq3_domain, "- epoch:", epoch_val),
                       x = "Âge (mois)", y = "PC15",
                       color = paste("Niveau", asq3_domain)) +
                  theme_bw()
                
                print(p_interaction)
                cat("Graphique d'interaction créé\n")
                
              }, error = function(e) {
                cat("Erreur graphique interaction:", e$message, "\n")
              })
            }
            
          }, error = function(e) {
            cat("Erreur modèle pour epoch", epoch_val, ":", e$message, "\n")
            epoch_results[[epoch_val]] <- list(
              error = e$message,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data)
            )
          })
          
        } else {
          cat("Variable ASQ3 pas assez variable pour cette epoch (", length(unique_values), " valeurs uniques)\n")
          epoch_results[[epoch_val]] <- list(
            issue = "insufficient_variability",
            epoch = epoch_val,
            domain = asq3_domain,
            n_obs = nrow(epoch_data)
          )
        }
        
      } else {
        cat("Données insuffisantes pour epoch", epoch_val, "(n =", nrow(epoch_data), ")\n")
        epoch_results[[epoch_val]] <- list(
          issue = "insufficient_data",
          epoch = epoch_val,
          domain = asq3_domain,
          n_obs = nrow(epoch_data)
        )
      }
    }
    
    # RETOURNER TOUS LES RÉSULTATS D'epoch
    return(epoch_results)
    
  } else {
    cat(" Données insuffisantes globalement (n =", nrow(subset_data), ")\n")
    return(list(global_issue = "insufficient_data", n_obs = nrow(subset_data)))
  }
}


# Exécuter le diagnostic avant l'analyse
diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat("ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}


# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat("  epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat("  Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("Statut inconnu\n")
      }
    }
  } else {
    cat("Résultats non disponibles\n")
  }
}


# Fonction pour sauvegarder tous les résultats
save_asq3_results <- function() {
  output_file <- "ASQ3_PC15_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC15 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

# Sauvegarder les résultats
save_asq3_results()

```





```{r PC16_GCA_ASQ3_Analysis}
library(dplyr)
library(car)
library(ggplot2)
library(lme4)
library(interactions)
library(emmeans)
library(ggeffects)
library(reshape2)

three_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_three.csv')
six_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_six.csv')
twelve_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_twelve.csv')

asq3_3m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/3_ASQ-4months_scores.csv')
asq3_6m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/6_ASQ-6months_scores.csv')
asq3_12m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/12_ASQ-12months_scores.csv')

print(colnames(asq3_3m))
print(colnames(asq3_6m))
print(colnames(asq3_12m))

# Fusion des données PC
merged_df <- bind_rows(
  mutate(three_df, df_source = "three", age_months = 3),
  mutate(six_df, df_source = "six", age_months = 6),
  mutate(twelve_df, df_source = "twelve", age_months = 12)
) %>%
  arrange(subject)

# convertit variable age en numérique 
merged_df$age[merged_df$age == 'three'] <- 3
merged_df$age[merged_df$age == 'six'] <- 6
merged_df$age[merged_df$age == 'twelve'] <- 12
merged_df$age <- as.numeric(merged_df$age)

# Préparation des données ASQ3
asq3_3m$age_months <- 3
asq3_6m$age_months <- 6
asq3_12m$age_months <- 12

# Fusion des données ASQ3
asq3_all <- bind_rows(asq3_3m, asq3_6m, asq3_12m) %>%
  select(subject, age_months, communication, gmotor, fmotor, pbsolving, social)

# Fusion des données PC avec ASQ3
data_combined <- merged_df %>%
  left_join(asq3_all, by = c("subject", "age_months"))

# Vérification de la fusion
cat("Nombre de lignes avant fusion:", nrow(merged_df), "\n")
cat("Nombre de lignes après fusion:", nrow(data_combined), "\n")
cat("Nombre de sujets avec données ASQ3:", sum(!is.na(data_combined$communication)), "\n")

# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC16 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC16 = mean(PC16, na.rm = TRUE),
    se_PC16 = sd(PC16, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC16, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC16 - se_PC16, ymax = mean_PC16 + se_PC16), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC16 par âge et epoch",
       x = "Âge (mois)", y = "PC16 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC16 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat("Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC16 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC16") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat("Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC16 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC16") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat("Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
            # Graphique d'interaction simple
            if (length(interaction_effects) > 0) {
              cat("Création du graphique d'interaction...\n")
              tryCatch({
                # Créer des niveaux de la variable ASQ3 pour la visualisation
                epoch_data$asq3_level <- cut(epoch_data[[asq3_domain]], 
                                             breaks = 3, 
                                             labels = c("Faible", "Moyen", "Élevé"))
                
                p_interaction <- ggplot(epoch_data, aes(x = age, y = PC16, color = asq3_level)) +
                  geom_smooth(method = "loess", se = TRUE) +
                  geom_point(alpha = 0.5) +
                  labs(title = paste("Interaction Age ×", asq3_domain, "- epoch:", epoch_val),
                       x = "Âge (mois)", y = "PC16",
                       color = paste("Niveau", asq3_domain)) +
                  theme_bw()
                
                print(p_interaction)
                cat("Graphique d'interaction créé\n")
                
              }, error = function(e) {
                cat("Erreur graphique interaction:", e$message, "\n")
              })
            }
            
          }, error = function(e) {
            cat("Erreur modèle pour epoch", epoch_val, ":", e$message, "\n")
            epoch_results[[epoch_val]] <- list(
              error = e$message,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data)
            )
          })
          
        } else {
          cat("Variable ASQ3 pas assez variable pour cette epoch (", length(unique_values), " valeurs uniques)\n")
          epoch_results[[epoch_val]] <- list(
            issue = "insufficient_variability",
            epoch = epoch_val,
            domain = asq3_domain,
            n_obs = nrow(epoch_data)
          )
        }
        
      } else {
        cat("Données insuffisantes pour epoch", epoch_val, "(n =", nrow(epoch_data), ")\n")
        epoch_results[[epoch_val]] <- list(
          issue = "insufficient_data",
          epoch = epoch_val,
          domain = asq3_domain,
          n_obs = nrow(epoch_data)
        )
      }
    }
    
    # RETOURNER TOUS LES RÉSULTATS D'epoch
    return(epoch_results)
    
  } else {
    cat(" Données insuffisantes globalement (n =", nrow(subset_data), ")\n")
    return(list(global_issue = "insufficient_data", n_obs = nrow(subset_data)))
  }
}


# Exécuter le diagnostic avant l'analyse
diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat("ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}


# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat("  epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat("  Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("Statut inconnu\n")
      }
    }
  } else {
    cat("Résultats non disponibles\n")
  }
}


# Fonction pour sauvegarder tous les résultats
save_asq3_results <- function() {
  output_file <- "ASQ3_PC16_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC16 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

# Sauvegarder les résultats
save_asq3_results()

```




```{r PC17_GCA_ASQ3_Analysis}
library(dplyr)
library(car)
library(ggplot2)
library(lme4)
library(interactions)
library(emmeans)
library(ggeffects)
library(reshape2)

three_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_three.csv')
six_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_six.csv')
twelve_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_twelve.csv')

asq3_3m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/3_ASQ-4months_scores.csv')
asq3_6m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/6_ASQ-6months_scores.csv')
asq3_12m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/12_ASQ-12months_scores.csv')

print(colnames(asq3_3m))
print(colnames(asq3_6m))
print(colnames(asq3_12m))

# Fusion des données PC
merged_df <- bind_rows(
  mutate(three_df, df_source = "three", age_months = 3),
  mutate(six_df, df_source = "six", age_months = 6),
  mutate(twelve_df, df_source = "twelve", age_months = 12)
) %>%
  arrange(subject)

# convertit variable age en numérique 
merged_df$age[merged_df$age == 'three'] <- 3
merged_df$age[merged_df$age == 'six'] <- 6
merged_df$age[merged_df$age == 'twelve'] <- 12
merged_df$age <- as.numeric(merged_df$age)

# Préparation des données ASQ3
asq3_3m$age_months <- 3
asq3_6m$age_months <- 6
asq3_12m$age_months <- 12

# Fusion des données ASQ3
asq3_all <- bind_rows(asq3_3m, asq3_6m, asq3_12m) %>%
  select(subject, age_months, communication, gmotor, fmotor, pbsolving, social)

# Fusion des données PC avec ASQ3
data_combined <- merged_df %>%
  left_join(asq3_all, by = c("subject", "age_months"))

# Vérification de la fusion
cat("Nombre de lignes avant fusion:", nrow(merged_df), "\n")
cat("Nombre de lignes après fusion:", nrow(data_combined), "\n")
cat("Nombre de sujets avec données ASQ3:", sum(!is.na(data_combined$communication)), "\n")

# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC17 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC17 = mean(PC17, na.rm = TRUE),
    se_PC17 = sd(PC17, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC17, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC17 - se_PC17, ymax = mean_PC17 + se_PC17), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC17 par âge et epoch",
       x = "Âge (mois)", y = "PC17 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC17 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat("Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC17 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC17") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat("Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC17 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC17") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat("Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
            # Graphique d'interaction simple
            if (length(interaction_effects) > 0) {
              cat("Création du graphique d'interaction...\n")
              tryCatch({
                # Créer des niveaux de la variable ASQ3 pour la visualisation
                epoch_data$asq3_level <- cut(epoch_data[[asq3_domain]], 
                                             breaks = 3, 
                                             labels = c("Faible", "Moyen", "Élevé"))
                
                p_interaction <- ggplot(epoch_data, aes(x = age, y = PC17, color = asq3_level)) +
                  geom_smooth(method = "loess", se = TRUE) +
                  geom_point(alpha = 0.5) +
                  labs(title = paste("Interaction Age ×", asq3_domain, "- epoch:", epoch_val),
                       x = "Âge (mois)", y = "PC17",
                       color = paste("Niveau", asq3_domain)) +
                  theme_bw()
                
                print(p_interaction)
                cat("Graphique d'interaction créé\n")
                
              }, error = function(e) {
                cat("Erreur graphique interaction:", e$message, "\n")
              })
            }
            
          }, error = function(e) {
            cat("Erreur modèle pour epoch", epoch_val, ":", e$message, "\n")
            epoch_results[[epoch_val]] <- list(
              error = e$message,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data)
            )
          })
          
        } else {
          cat("Variable ASQ3 pas assez variable pour cette epoch (", length(unique_values), " valeurs uniques)\n")
          epoch_results[[epoch_val]] <- list(
            issue = "insufficient_variability",
            epoch = epoch_val,
            domain = asq3_domain,
            n_obs = nrow(epoch_data)
          )
        }
        
      } else {
        cat("Données insuffisantes pour epoch", epoch_val, "(n =", nrow(epoch_data), ")\n")
        epoch_results[[epoch_val]] <- list(
          issue = "insufficient_data",
          epoch = epoch_val,
          domain = asq3_domain,
          n_obs = nrow(epoch_data)
        )
      }
    }
    
    # RETOURNER TOUS LES RÉSULTATS D'epoch
    return(epoch_results)
    
  } else {
    cat(" Données insuffisantes globalement (n =", nrow(subset_data), ")\n")
    return(list(global_issue = "insufficient_data", n_obs = nrow(subset_data)))
  }
}


# Exécuter le diagnostic avant l'analyse
diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat("ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}


# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat("  epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat("  Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("Statut inconnu\n")
      }
    }
  } else {
    cat("Résultats non disponibles\n")
  }
}


# Fonction pour sauvegarder tous les résultats
save_asq3_results <- function() {
  output_file <- "ASQ3_PC17_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC17 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

# Sauvegarder les résultats
save_asq3_results()

```




```{r PC18_GCA_ASQ3_Analysis}
library(dplyr)
library(car)
library(ggplot2)
library(lme4)
library(interactions)
library(emmeans)
library(ggeffects)
library(reshape2)

three_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_three.csv')
six_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_six.csv')
twelve_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_twelve.csv')

asq3_3m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/3_ASQ-4months_scores.csv')
asq3_6m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/6_ASQ-6months_scores.csv')
asq3_12m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/12_ASQ-12months_scores.csv')

print(colnames(asq3_3m))
print(colnames(asq3_6m))
print(colnames(asq3_12m))

# Fusion des données PC
merged_df <- bind_rows(
  mutate(three_df, df_source = "three", age_months = 3),
  mutate(six_df, df_source = "six", age_months = 6),
  mutate(twelve_df, df_source = "twelve", age_months = 12)
) %>%
  arrange(subject)

# convertit variable age en numérique 
merged_df$age[merged_df$age == 'three'] <- 3
merged_df$age[merged_df$age == 'six'] <- 6
merged_df$age[merged_df$age == 'twelve'] <- 12
merged_df$age <- as.numeric(merged_df$age)

# Préparation des données ASQ3
asq3_3m$age_months <- 3
asq3_6m$age_months <- 6
asq3_12m$age_months <- 12

# Fusion des données ASQ3
asq3_all <- bind_rows(asq3_3m, asq3_6m, asq3_12m) %>%
  select(subject, age_months, communication, gmotor, fmotor, pbsolving, social)

# Fusion des données PC avec ASQ3
data_combined <- merged_df %>%
  left_join(asq3_all, by = c("subject", "age_months"))

# Vérification de la fusion
cat("Nombre de lignes avant fusion:", nrow(merged_df), "\n")
cat("Nombre de lignes après fusion:", nrow(data_combined), "\n")
cat("Nombre de sujets avec données ASQ3:", sum(!is.na(data_combined$communication)), "\n")

# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC18 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC18 = mean(PC18, na.rm = TRUE),
    se_PC18 = sd(PC18, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC18, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC18 - se_PC18, ymax = mean_PC18 + se_PC18), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC18 par âge et epoch",
       x = "Âge (mois)", y = "PC18 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC18 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat("Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC18 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC18") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat("Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC18 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC18") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat("Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
            # Graphique d'interaction simple
            if (length(interaction_effects) > 0) {
              cat("Création du graphique d'interaction...\n")
              tryCatch({
                # Créer des niveaux de la variable ASQ3 pour la visualisation
                epoch_data$asq3_level <- cut(epoch_data[[asq3_domain]], 
                                             breaks = 3, 
                                             labels = c("Faible", "Moyen", "Élevé"))
                
                p_interaction <- ggplot(epoch_data, aes(x = age, y = PC18, color = asq3_level)) +
                  geom_smooth(method = "loess", se = TRUE) +
                  geom_point(alpha = 0.5) +
                  labs(title = paste("Interaction Age ×", asq3_domain, "- epoch:", epoch_val),
                       x = "Âge (mois)", y = "PC18",
                       color = paste("Niveau", asq3_domain)) +
                  theme_bw()
                
                print(p_interaction)
                cat("Graphique d'interaction créé\n")
                
              }, error = function(e) {
                cat("Erreur graphique interaction:", e$message, "\n")
              })
            }
            
          }, error = function(e) {
            cat("Erreur modèle pour epoch", epoch_val, ":", e$message, "\n")
            epoch_results[[epoch_val]] <- list(
              error = e$message,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data)
            )
          })
          
        } else {
          cat("Variable ASQ3 pas assez variable pour cette epoch (", length(unique_values), " valeurs uniques)\n")
          epoch_results[[epoch_val]] <- list(
            issue = "insufficient_variability",
            epoch = epoch_val,
            domain = asq3_domain,
            n_obs = nrow(epoch_data)
          )
        }
        
      } else {
        cat("Données insuffisantes pour epoch", epoch_val, "(n =", nrow(epoch_data), ")\n")
        epoch_results[[epoch_val]] <- list(
          issue = "insufficient_data",
          epoch = epoch_val,
          domain = asq3_domain,
          n_obs = nrow(epoch_data)
        )
      }
    }
    
    # RETOURNER TOUS LES RÉSULTATS D'epoch
    return(epoch_results)
    
  } else {
    cat(" Données insuffisantes globalement (n =", nrow(subset_data), ")\n")
    return(list(global_issue = "insufficient_data", n_obs = nrow(subset_data)))
  }
}


# Exécuter le diagnostic avant l'analyse
diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat("ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}


# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat("  epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat("  Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("Statut inconnu\n")
      }
    }
  } else {
    cat("Résultats non disponibles\n")
  }
}


# Fonction pour sauvegarder tous les résultats
save_asq3_results <- function() {
  output_file <- "ASQ3_PC18_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC18 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

# Sauvegarder les résultats
save_asq3_results()

```





```{r PC19_GCA_ASQ3_Analysis}
library(dplyr)
library(car)
library(ggplot2)
library(lme4)
library(interactions)
library(emmeans)
library(ggeffects)
library(reshape2)

three_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_three.csv')
six_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_six.csv')
twelve_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_twelve.csv')

asq3_3m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/3_ASQ-4months_scores.csv')
asq3_6m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/6_ASQ-6months_scores.csv')
asq3_12m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/12_ASQ-12months_scores.csv')

print(colnames(asq3_3m))
print(colnames(asq3_6m))
print(colnames(asq3_12m))

# Fusion des données PC
merged_df <- bind_rows(
  mutate(three_df, df_source = "three", age_months = 3),
  mutate(six_df, df_source = "six", age_months = 6),
  mutate(twelve_df, df_source = "twelve", age_months = 12)
) %>%
  arrange(subject)

# convertit variable age en numérique 
merged_df$age[merged_df$age == 'three'] <- 3
merged_df$age[merged_df$age == 'six'] <- 6
merged_df$age[merged_df$age == 'twelve'] <- 12
merged_df$age <- as.numeric(merged_df$age)

# Préparation des données ASQ3
asq3_3m$age_months <- 3
asq3_6m$age_months <- 6
asq3_12m$age_months <- 12

# Fusion des données ASQ3
asq3_all <- bind_rows(asq3_3m, asq3_6m, asq3_12m) %>%
  select(subject, age_months, communication, gmotor, fmotor, pbsolving, social)

# Fusion des données PC avec ASQ3
data_combined <- merged_df %>%
  left_join(asq3_all, by = c("subject", "age_months"))

# Vérification de la fusion
cat("Nombre de lignes avant fusion:", nrow(merged_df), "\n")
cat("Nombre de lignes après fusion:", nrow(data_combined), "\n")
cat("Nombre de sujets avec données ASQ3:", sum(!is.na(data_combined$communication)), "\n")

# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC19 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC19 = mean(PC19, na.rm = TRUE),
    se_PC19 = sd(PC19, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC19, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC19 - se_PC19, ymax = mean_PC19 + se_PC19), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC19 par âge et epoch",
       x = "Âge (mois)", y = "PC19 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC19 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat("Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC19 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC19") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat("Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC19 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC19") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat("Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
            # Graphique d'interaction simple
            if (length(interaction_effects) > 0) {
              cat("Création du graphique d'interaction...\n")
              tryCatch({
                # Créer des niveaux de la variable ASQ3 pour la visualisation
                epoch_data$asq3_level <- cut(epoch_data[[asq3_domain]], 
                                             breaks = 3, 
                                             labels = c("Faible", "Moyen", "Élevé"))
                
                p_interaction <- ggplot(epoch_data, aes(x = age, y = PC19, color = asq3_level)) +
                  geom_smooth(method = "loess", se = TRUE) +
                  geom_point(alpha = 0.5) +
                  labs(title = paste("Interaction Age ×", asq3_domain, "- epoch:", epoch_val),
                       x = "Âge (mois)", y = "PC19",
                       color = paste("Niveau", asq3_domain)) +
                  theme_bw()
                
                print(p_interaction)
                cat("Graphique d'interaction créé\n")
                
              }, error = function(e) {
                cat("Erreur graphique interaction:", e$message, "\n")
              })
            }
            
          }, error = function(e) {
            cat("Erreur modèle pour epoch", epoch_val, ":", e$message, "\n")
            epoch_results[[epoch_val]] <- list(
              error = e$message,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data)
            )
          })
          
        } else {
          cat("Variable ASQ3 pas assez variable pour cette epoch (", length(unique_values), " valeurs uniques)\n")
          epoch_results[[epoch_val]] <- list(
            issue = "insufficient_variability",
            epoch = epoch_val,
            domain = asq3_domain,
            n_obs = nrow(epoch_data)
          )
        }
        
      } else {
        cat("Données insuffisantes pour epoch", epoch_val, "(n =", nrow(epoch_data), ")\n")
        epoch_results[[epoch_val]] <- list(
          issue = "insufficient_data",
          epoch = epoch_val,
          domain = asq3_domain,
          n_obs = nrow(epoch_data)
        )
      }
    }
    
    # RETOURNER TOUS LES RÉSULTATS D'epoch
    return(epoch_results)
    
  } else {
    cat(" Données insuffisantes globalement (n =", nrow(subset_data), ")\n")
    return(list(global_issue = "insufficient_data", n_obs = nrow(subset_data)))
  }
}


# Exécuter le diagnostic avant l'analyse
diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat("ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}


# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat("  epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat("  Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("Statut inconnu\n")
      }
    }
  } else {
    cat("Résultats non disponibles\n")
  }
}


# Fonction pour sauvegarder tous les résultats
save_asq3_results <- function() {
  output_file <- "ASQ3_PC19_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC19 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

# Sauvegarder les résultats
save_asq3_results()

```





```{r PC20_GCA_ASQ3_Analysis}
library(dplyr)
library(car)
library(ggplot2)
library(lme4)
library(interactions)
library(emmeans)
library(ggeffects)
library(reshape2)

three_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_three.csv')
six_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_six.csv')
twelve_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_twelve.csv')

asq3_3m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/3_ASQ-4months_scores.csv')
asq3_6m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/6_ASQ-6months_scores.csv')
asq3_12m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/12_ASQ-12months_scores.csv')

print(colnames(asq3_3m))
print(colnames(asq3_6m))
print(colnames(asq3_12m))

# Fusion des données PC
merged_df <- bind_rows(
  mutate(three_df, df_source = "three", age_months = 3),
  mutate(six_df, df_source = "six", age_months = 6),
  mutate(twelve_df, df_source = "twelve", age_months = 12)
) %>%
  arrange(subject)

# convertit variable age en numérique 
merged_df$age[merged_df$age == 'three'] <- 3
merged_df$age[merged_df$age == 'six'] <- 6
merged_df$age[merged_df$age == 'twelve'] <- 12
merged_df$age <- as.numeric(merged_df$age)

# Préparation des données ASQ3
asq3_3m$age_months <- 3
asq3_6m$age_months <- 6
asq3_12m$age_months <- 12

# Fusion des données ASQ3
asq3_all <- bind_rows(asq3_3m, asq3_6m, asq3_12m) %>%
  select(subject, age_months, communication, gmotor, fmotor, pbsolving, social)

# Fusion des données PC avec ASQ3
data_combined <- merged_df %>%
  left_join(asq3_all, by = c("subject", "age_months"))

# Vérification de la fusion
cat("Nombre de lignes avant fusion:", nrow(merged_df), "\n")
cat("Nombre de lignes après fusion:", nrow(data_combined), "\n")
cat("Nombre de sujets avec données ASQ3:", sum(!is.na(data_combined$communication)), "\n")

# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC20 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC20 = mean(PC20, na.rm = TRUE),
    se_PC20 = sd(PC20, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC20, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC20 - se_PC20, ymax = mean_PC20 + se_PC20), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC20 par âge et epoch",
       x = "Âge (mois)", y = "PC20 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par âge
  cat("\nepoch par âge:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
  
  # Vérifier les sujets par epoch
  cat("\nNombre de sujets par epoch:\n")
  subject_counts <- data.gca %>%
    group_by(epoch) %>%
    summarise(
      n_subjects = length(unique(subject)),
      n_observations = n(),
      .groups = 'drop'
    )
  print(subject_counts)
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  # Filtrer les données avec des valeurs ASQ3 non manquantes
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Vérification des epoch disponibles
  epochs <- unique(subset_data$epoch)
  cat("epoch disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {  # Seuil minimum de données
    
    # STOCKAGE DES RÉSULTATS POUR CHAQUE epoch
    epoch_results <- list()
    
    # Analyse par epoch
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations pour epoch", epoch_val, ":", nrow(epoch_data), "\n")
      cat("Nombre de sujets pour epoch", epoch_val, ":", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        
        # Vérifier la variabilité de la variable ASQ3
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("Range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          # Créer la formule
          formula_mod <- as.formula(paste0("PC20 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            # Modèle avec modération ASQ3
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            
            cat("Modèle convergé pour", epoch_val, "\n")
            
            # Extraire les effets significatifs
            sig_results <- extract_significant_effects(lmer_mod)
            
            cat("Effets significatifs:\n")
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", round(effect_row$p_value, 4), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Sauvegarder les résultats de cette epoch
            epoch_results[[epoch_val]] <- list(
              model = lmer_mod,
              significance = sig_results,
              epoch = epoch_val,
              domain = asq3_domain,
              n_obs = nrow(epoch_data),
              n_subjects = length(unique(epoch_data$subject))
            )
            
            # Johnson-Neyman si interactions significatives
            interaction_effects <- sig_results$significant_effects[grepl(":", sig_results$significant_effects)]
            
            if (length(interaction_effects) > 0) {
              cat("\n Interactions significatives détectées - Analyse Johnson-Neyman:\n")
              
              # Pour poly1
              if (any(grepl(paste0("poly1.*", asq3_domain, "|", asq3_domain, ".*poly1"), interaction_effects))) {
                cat("Analyse JN pour poly1...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly1
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC20 ~ pred_var*mod_var + poly2*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly1 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly1$plot <- jn_poly1$plot + 
                    labs(title = paste("Interaction poly1 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for linear age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly1 sur PC20") +
                    theme_minimal()
                  
                  print(jn_poly1$plot)
                  cat("Johnson-Neyman poly1 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly1:", e$message, "\n")
                })
              }
              
              # Pour poly2
              if (any(grepl(paste0("poly2.*", asq3_domain, "|", asq3_domain, ".*poly2"), interaction_effects))) {
                cat("Analyse JN pour poly2...\n")
                tryCatch({
                  temp_data <- epoch_data
                  temp_data$pred_var <- temp_data$poly2
                  temp_data$mod_var <- temp_data[[asq3_domain]]
                  
                  temp_model <- lmer(PC20 ~ poly1*mod_var + pred_var*mod_var + (1|subject), 
                                     data = temp_data, REML = TRUE)
                  
                  jn_poly2 <- johnson_neyman(model = temp_model, pred = pred_var, modx = mod_var)
                  
                  # Améliorer le graphique
                  jn_poly2$plot <- jn_poly2$plot + 
                    labs(title = paste("Interaction poly2 ×", asq3_domain, "- epoch:", epoch_val),
                         subtitle = "Johnson-Neyman test for quadratic age trend",
                         x = paste("Niveau de", asq3_domain),
                         y = "Effet poly2 sur PC20") +
                    theme_minimal()
                  
                  print(jn_poly2$plot)
                  cat("Johnson-Neyman poly2 réussi\n")
                  
                }, error = function(e) {
                  cat("Erreur Johnson-Neyman poly2:", e$message, "\n")
                })
              }
            }
            
            # GRAPHIQUES BASÉS SUR LES PRÉDICTIONS DU MODÈLE
# ===============================================

          if (length(interaction_effects) > 0) {
            cat("Création des graphiques basés sur les prédictions du modèle...\n")
            tryCatch({
                
              # ÉTAPE 1 : DÉFINIR LES NIVEAUX ASQ3 REPRÉSENTATIFS
              # ================================================
              # Utilise les percentiles pour représenter la distribution réelle
              asq3_values <- quantile(epoch_data[[asq3_domain]], 
                                     probs = c(0.25, 0.5, 0.75), 
                                     na.rm = TRUE)
              
              cat("Niveaux ASQ3 utilisés:", paste(round(asq3_values, 2), collapse = ", "), "\n")
              
              # ÉTAPE 2 : PRÉDICTIONS POUR LES EFFETS POLYNOMIAUX
              # ================================================
              
              # 2a. Effet linéaire (poly1) selon niveaux ASQ3
              pred_poly1 <- ggpredict(lmer_mod, 
                                     terms = c("poly1 [all]", 
                                              paste0(asq3_domain, " [", 
                                                    paste(round(asq3_values, 2), collapse = ","), "]")))
              
              # 2b. Effet quadratique (poly2) selon niveaux ASQ3
              pred_poly2 <- ggpredict(lmer_mod, 
                                     terms = c("poly2 [all]", 
                                              paste0(asq3_domain, " [", 
                                                    paste(round(asq3_values, 2), collapse = ","), "]")))
              
              # ÉTAPE 3 : PRÉPARATION DES DONNÉES POUR VISUALISATION
              # ===================================================
              
              # Convertir en data.frames et ajouter identifiants
              pred_poly1_df <- as.data.frame(pred_poly1)
              pred_poly1_df$polynomial <- "Linéaire (poly1)"
              pred_poly1_df$effect_type <- "Tendance constante"
              
              pred_poly2_df <- as.data.frame(pred_poly2)
              pred_poly2_df$polynomial <- "Quadratique (poly2)"  
              pred_poly2_df$effect_type <- "Accélération/Décélération"
              
              # Combiner les deux types d'effets
              pred_combined <- rbind(pred_poly1_df, pred_poly2_df)
              
              # Renommer les groupes pour l'affichage
              pred_combined$asq3_level <- factor(pred_combined$group,
                                                levels = as.character(round(asq3_values, 2)),
                                                labels = paste0(asq3_domain, " P", c(25, 50, 75)))
              
              # ÉTAPE 4 : GRAPHIQUE DES EFFETS POLYNOMIAUX
              # =========================================
              
              p_effects <- ggplot(pred_combined, aes(x = x, y = predicted)) +
                # Intervalles de confiance
                geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = asq3_level), 
                            alpha = 0.2) +
                # Lignes principales
                geom_line(aes(color = asq3_level, linetype = polynomial), 
                          size = 1.3) +
                # Séparation par type d'effet
                facet_wrap(~effect_type, scales = "free_x") +
                
                labs(title = paste("Effets polynomiaux selon", asq3_domain, "- epoch:", epoch_val),
                     subtitle = "Prédictions du modèle mixte avec intervalles de confiance à 95%",
                     x = "Valeur polynomiale transformée", 
                     y = "PC20 prédit (unités standardisées)",
                     color = "Niveau ASQ3",
                     fill = "Niveau ASQ3",
                     linetype = "Composante") +
                
                # Esthétique
                scale_color_brewer(type = "qual", palette = "Dark2") +
                scale_fill_brewer(type = "qual", palette = "Dark2") +
                scale_linetype_manual(values = c("solid", "dashed")) +
                theme_bw() +
                theme(
                  plot.title = element_text(size = 13, face = "bold"),
                  plot.subtitle = element_text(size = 11),
                  strip.text = element_text(size = 10, face = "bold"),
                  legend.position = "bottom",
                  legend.title = element_text(size = 10),
                  axis.text = element_text(size = 9)
                )
              
              print(p_effects)
              cat("? Graphique des effets polynomiaux créé\n")
              
              # ÉTAPE 5 : TRAJECTOIRES DÉVELOPPEMENTALES COMPLÈTES
              # =================================================
              
              # 5a. Créer une séquence fine d'âges pour des courbes lisses
              age_range <- range(epoch_data$age, na.rm = TRUE)
              age_seq <- seq(age_range[1], age_range[2], length.out = 100)
              
              # 5b. Grille de prédiction : tous les âges × tous les niveaux ASQ3
              pred_grid <- expand.grid(
                age = age_seq,
                asq3_val = asq3_values
              )
              
              # 5c. Appliquer la même transformation polynomiale que le modèle original
              # CRUCIAL : Utilise exactement la même fonction que votre analyse principale
              pred_grid <- code.poly(df = pred_grid, predictor = "age", poly.order = 2, 
                                    orthogonal = TRUE, draw.poly = FALSE)
              
              # 5d. Ajouter la variable ASQ3 avec le bon nom
              pred_grid[[asq3_domain]] <- pred_grid$asq3_val
              
              # 5e. Créer les étiquettes pour l'affichage
              pred_grid$asq3_level <- factor(pred_grid$asq3_val, 
                                            levels = asq3_values,
                                            labels = paste0(asq3_domain, " P", c(25, 50, 75)))
              
              # 5f. PRÉDICTIONS DU MODÈLE (effets fixes seulement)
              pred_grid$predicted <- predict(lmer_mod, newdata = pred_grid, re.form = NA)
              
              # 5g. Calculer les intervalles de confiance (approximation)
              # Note: Pour des IC exacts, il faudrait utiliser bootMer(), mais c'est plus lent
              pred_matrix <- model.matrix(~ poly1 * get(asq3_domain) + poly2 * get(asq3_domain), 
                                         data = pred_grid)
              pred_var <- diag(pred_matrix %*% vcov(lmer_mod) %*% t(pred_matrix))
              pred_grid$se <- sqrt(pred_var)
              pred_grid$conf_low <- pred_grid$predicted - 1.96 * pred_grid$se
              pred_grid$conf_high <- pred_grid$predicted + 1.96 * pred_grid$se
              
              # ÉTAPE 6 : GRAPHIQUE DES TRAJECTOIRES DÉVELOPPEMENTALES
              # =====================================================
              
              # 6a. Préparer les données observées avec classification ASQ3
              epoch_data$asq3_quartile <- cut(epoch_data[[asq3_domain]], 
                                             breaks = c(-Inf, asq3_values, Inf),
                                             labels = c("< P25", "P25-P50", "P50-P75", "> P75"),
                                             include.lowest = TRUE)
              
              # 6b. Créer le graphique principal
              p_trajectories <- ggplot() +
                
                # Intervalles de confiance des prédictions
                geom_ribbon(data = pred_grid,
                            aes(x = age, ymin = conf_low, ymax = conf_high, fill = asq3_level),
                            alpha = 0.2) +
                
                # Trajectoires prédites (lignes principales)
                geom_line(data = pred_grid,
                          aes(x = age, y = predicted, color = asq3_level),
                          size = 2, alpha = 0.9) +
                
                # Points observés (données réelles)
                geom_point(data = epoch_data[!is.na(epoch_data$asq3_quartile), ],
                          aes(x = age, y = PC20, color = asq3_quartile),
                          alpha = 0.6, size = 2, shape = 16) +
                
                # Moyennes observées par âge et niveau ASQ3
                stat_summary(data = epoch_data[!is.na(epoch_data$asq3_quartile), ],
                             aes(x = age, y = PC20, color = asq3_quartile),
                             fun = mean, geom = "point", size = 4, shape = 17, alpha = 0.8) +
                
                # Esthétique et labels
                labs(title = paste("Trajectoires développementales de PC20 selon", asq3_domain),
                     subtitle = paste("Epoch:", epoch_val, "? Lignes = prédictions du modèle ? Points = données observées ? Triangles = moyennes"),
                     x = "Âge (mois)", 
                     y = "PC20 (score standardisé)",
                     color = paste("Niveau", asq3_domain),
                     fill = paste("Niveau", asq3_domain)) +
                
                # Couleurs et thème
                scale_color_brewer(type = "qual", palette = "Set1") +
                scale_fill_brewer(type = "qual", palette = "Set1") +
                scale_x_continuous(breaks = unique(epoch_data$age)) +
                theme_bw() +
                theme(
                  plot.title = element_text(size = 14, face = "bold"),
                  plot.subtitle = element_text(size = 11),
                  legend.position = "bottom",
                  legend.title = element_text(size = 11, face = "bold"),
                  legend.text = element_text(size = 10),
                  axis.title = element_text(size = 12),
                  axis.text = element_text(size = 10),
                  panel.grid.minor = element_blank()
                ) +
                
                # Guides pour améliorer la légende
                guides(
                  color = guide_legend(override.aes = list(size = 3, alpha = 1)),
                  fill = guide_legend(override.aes = list(alpha = 0.3))
                )
              
              print(p_trajectories)
              cat("? Graphique des trajectoires développementales créé\n")
              
              # ÉTAPE 7 : STATISTIQUES DESCRIPTIVES POUR INTERPRÉTATION
              # ======================================================
              
              cat("\n--- STATISTIQUES POUR INTERPRÉTATION ---\n")
              
              # Différences entre niveaux ASQ3 à chaque âge
              age_effects <- pred_grid %>%
                select(age, asq3_level, predicted) %>%
                pivot_wider(names_from = asq3_level, values_from = predicted) %>%
                mutate(
                  diff_P75_P25 = get(paste0(asq3_domain, " P75")) - get(paste0(asq3_domain, " P25")),
                  diff_P50_P25 = get(paste0(asq3_domain, " P50")) - get(paste0(asq3_domain, " P25"))
                )
              
              cat("Différences prédites entre niveaux ASQ3 :\n")
              cat("À 3 mois - P75 vs P25:", round(age_effects$diff_P75_P25[1], 3), "\n")
              cat("À 12 mois - P75 vs P25:", round(age_effects$diff_P75_P25[nrow(age_effects)], 3), "\n")
              
              # Pentes développementales par groupe
              slopes <- pred_grid %>%
                group_by(asq3_level) %>%
                do(model = lm(predicted ~ age, data = .)) %>%
                mutate(slope = map_dbl(model, ~ coef(.)[2]))
              
              cat("Pentes développementales (changement par mois) :\n")
              for(i in 1:nrow(slopes)) {
                cat("-", slopes$asq3_level[i], ":", round(slopes$slope[i], 4), "\n")
              }
              
              cat("? Graphiques basés sur le modèle créés avec succès\n")
              
            }, error = function(e) {
              cat("? Erreur dans les graphiques basés sur le modèle:", e$message, "\n")
              cat("Détails:", paste(e$call, collapse = " "), "\n")
            })
          }
        


# Exécuter le diagnostic avant l'analyse
diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat("ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}


# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat("  epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat("  Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("Statut inconnu\n")
      }
    }
  } else {
    cat("Résultats non disponibles\n")
  }
}


# Fonction pour sauvegarder tous les résultats
save_asq3_results <- function() {
  output_file <- "ASQ3_PC20_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  cat("ANALYSE GCA PC20 AVEC MODÉRATION ASQ3\n")
  cat("Date:", format(Sys.Date(), "%d/%m/%Y"), "\n")
  cat("Heure:", format(Sys.time(), "%H:%M:%S"), "\n\n")
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
  
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

# Sauvegarder les résultats
save_asq3_results()

```











































Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
