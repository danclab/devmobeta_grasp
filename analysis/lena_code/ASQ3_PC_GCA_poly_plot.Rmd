---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 


```{r PC7_GCA_ASQ3_Analysis}
library(dplyr)
library(car)
library(ggplot2)
library(lme4)
library(interactions)
library(emmeans)
library(ggeffects)
library(reshape2)
library(tidyr)
library(tibble)

  
three_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_three.csv')
six_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_six.csv')
twelve_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_twelve.csv')

asq3_3m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/3_ASQ-4months_scores.csv')
asq3_6m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/6_ASQ-6months_scores.csv')
asq3_12m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/12_ASQ-12months_scores.csv')

print(colnames(asq3_3m))
print(colnames(asq3_6m))
print(colnames(asq3_12m))

# Fusion des données PC
merged_df <- bind_rows(
  mutate(three_df, df_source = "three", age_months = 3),
  mutate(six_df, df_source = "six", age_months = 6),
  mutate(twelve_df, df_source = "twelve", age_months = 12)
) %>%
  arrange(subject)

# convertit variable age en numérique 
merged_df$age[merged_df$age == 'three'] <- 3
merged_df$age[merged_df$age == 'six'] <- 6
merged_df$age[merged_df$age == 'twelve'] <- 12
merged_df$age <- as.numeric(merged_df$age)

# Préparation des données ASQ3
asq3_3m$age_months <- 3
asq3_6m$age_months <- 6
asq3_12m$age_months <- 12

# Fusion des données ASQ3
asq3_all <- bind_rows(asq3_3m, asq3_6m, asq3_12m) %>%
  select(subject, age_months, communication, gmotor, fmotor, pbsolving, social)

# Fusion des données PC avec ASQ3
data_combined <- merged_df %>%
  left_join(asq3_all, by = c("subject", "age_months"))

# Vérification de la fusion
cat("Nombre de lignes avant fusion:", nrow(merged_df), "\n")
cat("Nombre de lignes après fusion:", nrow(data_combined), "\n")
cat("Nombre de sujets avec données ASQ3:", sum(!is.na(data_combined$communication)), "\n")

# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC7 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC7 = mean(PC7, na.rm = TRUE),
    se_PC7 = sd(PC7, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC7, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC7 - se_PC7, ymax = mean_PC7 + se_PC7), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC7 par age et epoch",
       x = "age (mois)", y = "PC7 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par age
  cat("\nepoch par age:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Calculer et afficher nombre de sujets par epoch
  subject_counts <- subset_data %>% 
    group_by(epoch) %>% 
    summarise(n_subjects = n_distinct(subject))
  
  cat("Nombre de sujets par epoch:\n")
  print(subject_counts)
  
  epochs <- unique(subset_data$epoch)
  cat("epochs disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {
    
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations:", nrow(epoch_data), "\n")
      cat("Nombre de sujets:", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          formula_mod <- as.formula(paste0("PC7 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            cat("Modèle convergé pour", epoch_val, "\n")
            
            sig_results <- extract_significant_effects(lmer_mod)
            cat("Effets significatifs:\n")
            
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, 
                    " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", signif(effect_row$p_value, 3), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Préparer les groupes ASQ3 en 3 groupes 
            thresholds <- tibble(
              age = c(3, 3, 3, 3, 3, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12), 
              domain = c("communication","gmotor","fmotor","pbsolving","social",
                         "communication","gmotor","fmotor","pbsolving","social",
                         "communication","gmotor","fmotor","pbsolving","social"), 
              low_cutoff = c(5.8, 6.33, 5, 5.8, 5.5, 
                             4.9, 3.70, 4.19, 4.62, 4.22, 
                             5.21, 3.58, 5.75, 4.55, 3.62), 
              medium_cutoff = c(7.33, 7.67, 6.67, 7.33, 7.17,
                                6.83, 5.67, 6.17, 6.5, 6.17, 
                                5, 5.83, 7, 6.17, 5.67), 
            )  
            
            classify_score <- function(score, age, domain, thresholds_df) {
              row <- thresholds_df %>%
                filter(age == !!age, domain == !!domain)
              
              if (nrow(row) == 0) {
                warning(paste("Aucun seuil trouvé pour age =", age, "et domain =", domain))
                return(NA)
              }
              
              low_cutoff <- row$low_cutoff
              medium_cutoff <- row$medium_cutoff
              
              if (score < low_cutoff) {
                return("low")
              } else if (score < medium_cutoff) {
                return("medium")
              } else {
                return("high")
              }
            }
            
            # créé colonne ASQ3_group dans epoch_data (low, medium, high)
            epoch_data <- epoch_data %>%
              rowwise() %>%
              mutate(ASQ_group = classify_score(get(asq3_domain), age, asq3_domain, thresholds)) %>%
              ungroup()
            
            # Graphique avec tendances poly1 (linéaire) et poly2 (quadratique)
            p <- ggplot(epoch_data, aes(x = age, y = PC7, color = ASQ_group)) +
              geom_smooth(method = "lm", formula = y ~ poly(x, 1, raw = TRUE), 
                          se = FALSE, size = 1.2, linetype = "solid") +  # poly1 = ligne pleine
              geom_smooth(method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
                          se = FALSE, size = 1.2, linetype = "dashed") + # poly2 = pointillée
              labs(
                title = paste("PC7 trajectories by ASQ3 levels :", asq3_domain, "- epoch", epoch_val),
                x = "age (months)",
                y = "PC7",
                color = "ASQ3 levels"
              ) +
              theme_minimal(base_size = 14) +
              theme(legend.position = "bottom")
            
            print(p)
            
          }, error = function(e) {
            cat("Erreur lmer:", e$message, "\n")
          })
        } else {
          cat("Pas assez de valeurs uniques pour modéliser (minimum 3 requis)\n")
        }
      } else {
        cat("Pas assez de données pour cet epoch (minimum 10 requis)\n")
      }
    }
  } else {
    cat("Pas assez de données globales pour cette analyse (minimum 20 requis)\n")
  }
}


diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat(" ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}

# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat(" Epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat(" ? Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("  Statut inconnu\n")
      }
    }
  } else {
    cat("  Résultats non disponibles\n")
  }
}

save_asq3_results <- function() {
  output_file <- "ASQ3_PC7_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
   
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

save_asq3_results()

```

```{r PC6_GCA_ASQ3_Analysis}
library(dplyr)
library(car)
library(ggplot2)
library(lme4)
library(interactions)
library(emmeans)
library(ggeffects)
library(reshape2)
library(tidyr)
library(tibble)

  
three_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_three.csv')
six_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_six.csv')
twelve_df <- read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_twelve.csv')

asq3_3m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/3_ASQ-4months_scores.csv')
asq3_6m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/6_ASQ-6months_scores.csv')
asq3_12m <- read.csv('/home/ldurieux/devmobeta_grasp/analysis/questionnaires/ASQ/12_ASQ-12months_scores.csv')

print(colnames(asq3_3m))
print(colnames(asq3_6m))
print(colnames(asq3_12m))

# Fusion des données PC
merged_df <- bind_rows(
  mutate(three_df, df_source = "three", age_months = 3),
  mutate(six_df, df_source = "six", age_months = 6),
  mutate(twelve_df, df_source = "twelve", age_months = 12)
) %>%
  arrange(subject)

# convertit variable age en numérique 
merged_df$age[merged_df$age == 'three'] <- 3
merged_df$age[merged_df$age == 'six'] <- 6
merged_df$age[merged_df$age == 'twelve'] <- 12
merged_df$age <- as.numeric(merged_df$age)

# Préparation des données ASQ3
asq3_3m$age_months <- 3
asq3_6m$age_months <- 6
asq3_12m$age_months <- 12

# Fusion des données ASQ3
asq3_all <- bind_rows(asq3_3m, asq3_6m, asq3_12m) %>%
  select(subject, age_months, communication, gmotor, fmotor, pbsolving, social)

# Fusion des données PC avec ASQ3
data_combined <- merged_df %>%
  left_join(asq3_all, by = c("subject", "age_months"))

# Vérification de la fusion
cat("Nombre de lignes avant fusion:", nrow(merged_df), "\n")
cat("Nombre de lignes après fusion:", nrow(data_combined), "\n")
cat("Nombre de sujets avec données ASQ3:", sum(!is.na(data_combined$communication)), "\n")

# Fonction pour créer les polynômes orthogonaux
code.poly <- function(df = NULL, predictor = NULL, poly.order = NULL, orthogonal = TRUE, draw.poly = TRUE) {
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal - 1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)) {
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[[predictor]]
  
  # create index of predictor (e.g. numbered time bins)
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  # create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw = raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  df[, paste("poly", 1:poly.order, sep = "")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE) {
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep = ""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars = predictor)
    
    # Make level names intuitive
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable) == "poly2"] <- "Quadratic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y = value, color = Order)) +
      aes_string(x = predictor) +
      geom_line() +
      xlab(paste0(predictor, " (transformed polynomials)")) +
      ylab("Transformed value") +
      scale_color_brewer(palette = "Set1") +
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor, ".Index")
  return(df)
}

# Application des polynômes orthogonaux
data.gca <- code.poly(df = data_combined, predictor = "age", poly.order = 2, orthogonal = TRUE, draw.poly = TRUE)

# Modèle principal (sans modération ASQ3)
cat("\n=== MODÈLE PRINCIPAL (sans ASQ3) ===\n")
lmer_main <- lmer(PC6 ~ epoch * (poly1 + poly2) + (1 | subject), data = data.gca, REML = TRUE)
print(summary(lmer_main))

lmer_main_results <- Anova(lmer_main, type = 3)
print(lmer_main_results)

# Visualisation du modèle principal
summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC6 = mean(PC6, na.rm = TRUE),
    se_PC6 = sd(PC6, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

p_main <- ggplot(summary_data, aes(x = age, y = mean_PC6, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC6 - se_PC6, ymax = mean_PC6 + se_PC6), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC6 par age et epoch",
       x = "age (mois)", y = "PC6 score ± SE") +
  theme_bw()

print(p_main)

# Domaines ASQ3 à tester
asq3_domains <- c("communication", "gmotor", "fmotor", "pbsolving", "social")

# Fonction pour extraire les effets significatifs
extract_significant_effects <- function(model, alpha = 0.05) {
  anova_results <- Anova(model, type = 3)
  p_values <- anova_results$`Pr(>Chisq)`
  effect_names <- rownames(anova_results)
  significant_effects <- effect_names[p_values < alpha & !is.na(p_values)]
  
  return(list(
    anova_table = anova_results,
    significant_effects = significant_effects,
    all_effects = data.frame(
      Effect = effect_names,
      ChiSq = anova_results$Chisq,
      Df = anova_results$Df,
      p_value = p_values,
      Significant = ifelse(p_values < alpha & !is.na(p_values), "***", "")
    )
  ))
}
# Fonction pour diagnostiquer les données
diagnose_data <- function() {
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("DIAGNOSTIC DES DONNÉES\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  
  # Vérifier les epoch
  cat("epoch dans les données:\n")
  print(table(data.gca$epoch, useNA = "ifany"))
  
  # Vérifier par age
  cat("\nepoch par age:\n")
  print(table(data.gca$age, data.gca$epoch, useNA = "ifany"))
  
  # Vérifier les données ASQ3 par epoch
  cat("\nDonnées ASQ3 par epoch:\n")
  for (domain in asq3_domains) {
    if (domain %in% colnames(data.gca)) {
      cat("\n", domain, ":\n")
      epoch_counts <- data.gca %>%
        group_by(epoch) %>%
        summarise(
          total = n(),
          non_na = sum(!is.na(.data[[domain]])),
          prop_complete = round(non_na/total*100, 1),
          .groups = 'drop'
        )
      print(epoch_counts)
    }
  }
}
# Fonction pour analyser chaque domaine ASQ3
analyze_asq3_moderator <- function(asq3_domain) {
  
  cat("\n", paste(rep("*", 60), collapse = ""), "\n")
  cat("ANALYSE POUR:", toupper(asq3_domain), "\n")
  cat(paste(rep("*", 60), collapse = ""), "\n")
  
  subset_data <- data.gca[!is.na(data.gca[[asq3_domain]]), ]
  
  cat("Nombre d'observations avec données", asq3_domain, ":", nrow(subset_data), "\n")
  cat("Nombre de sujets uniques:", length(unique(subset_data$subject)), "\n")
  
  # Calculer et afficher nombre de sujets par epoch
  subject_counts <- subset_data %>% 
    group_by(epoch) %>% 
    summarise(n_subjects = n_distinct(subject))
  
  cat("Nombre de sujets par epoch:\n")
  print(subject_counts)
  
  epochs <- unique(subset_data$epoch)
  cat("epochs disponibles:", paste(epochs, collapse = ", "), "\n")
  
  if (nrow(subset_data) > 20) {
    
    for (epoch_val in epochs) {
      cat("\n=== epoch:", epoch_val, "===\n")
      
      epoch_data <- subset_data[subset_data$epoch == epoch_val, ]
      
      cat("Nombre d'observations:", nrow(epoch_data), "\n")
      cat("Nombre de sujets:", length(unique(epoch_data$subject)), "\n")
      
      if (nrow(epoch_data) > 10) {
        asq3_values <- epoch_data[[asq3_domain]]
        unique_values <- unique(asq3_values[!is.na(asq3_values)])
        
        cat("Valeurs uniques ASQ3:", length(unique_values), "\n")
        cat("range ASQ3:", min(unique_values, na.rm = TRUE), "-", max(unique_values, na.rm = TRUE), "\n")
        
        if (length(unique_values) > 2) {
          
          formula_mod <- as.formula(paste0("PC6 ~ poly1*", asq3_domain, 
                                           " + poly2*", asq3_domain, " + (1|subject)"))
          
          tryCatch({
            lmer_mod <- lmer(formula_mod, data = epoch_data, REML = TRUE)
            cat("Modèle convergé pour", epoch_val, "\n")
            
            sig_results <- extract_significant_effects(lmer_mod)
            cat("Effets significatifs:\n")
            
            if (length(sig_results$significant_effects) > 0) {
              for (effect in sig_results$significant_effects) {
                effect_row <- sig_results$all_effects[sig_results$all_effects$Effect == effect, ]
                cat("- ", effect, 
                    " (Chi² = ", round(effect_row$ChiSq, 3), 
                    ", p = ", signif(effect_row$p_value, 3), ")\n")
              }
            } else {
              cat("Aucun effet significatif\n")
            }
            
            # Préparer les groupes ASQ3 en 3 groupes 
            thresholds <- tibble(
              age = c(3, 3, 3, 3, 3, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12), 
              domain = c("communication","gmotor","fmotor","pbsolving","social",
                         "communication","gmotor","fmotor","pbsolving","social",
                         "communication","gmotor","fmotor","pbsolving","social"), 
              low_cutoff = c(5.8, 6.33, 5, 5.8, 5.5, 
                             4.9, 3.70, 4.19, 4.62, 4.22, 
                             5.21, 3.58, 5.75, 4.55, 3.62), 
              medium_cutoff = c(7.33, 7.67, 6.67, 7.33, 7.17,
                                6.83, 5.67, 6.17, 6.5, 6.17, 
                                5, 5.83, 7, 6.17, 5.67), 
            )  
            
            classify_score <- function(score, age, domain, thresholds_df) {
              row <- thresholds_df %>%
                filter(age == !!age, domain == !!domain)
              
              if (nrow(row) == 0) {
                warning(paste("Aucun seuil trouvé pour age =", age, "et domain =", domain))
                return(NA)
              }
              
              low_cutoff <- row$low_cutoff
              medium_cutoff <- row$medium_cutoff
              
              if (score < low_cutoff) {
                return("low")
              } else if (score < medium_cutoff) {
                return("medium")
              } else {
                return("high")
              }
            }
            
            # créé colonne ASQ3_group dans epoch_data (low, medium, high)
            epoch_data <- epoch_data %>%
              rowwise() %>%
              mutate(ASQ_group = classify_score(get(asq3_domain), age, asq3_domain, thresholds)) %>%
              ungroup()
            
            # Graphique avec tendances poly1 (linéaire) et poly2 (quadratique)
            p <- ggplot(epoch_data, aes(x = age, y = PC6, color = ASQ_group)) +
              geom_smooth(method = "lm", formula = y ~ poly(x, 1, raw = TRUE), 
                          se = FALSE, size = 1.2, linetype = "solid") +  # poly1 = ligne pleine
              geom_smooth(method = "lm", formula = y ~ poly(x, 2, raw = TRUE), 
                          se = FALSE, size = 1.2, linetype = "dashed") + # poly2 = pointillée
              labs(
                title = paste("PC6 trajectories by ASQ3 levels :", asq3_domain, "- epoch", epoch_val),
                x = "age (months)",
                y = "PC6",
                color = "ASQ3 levels"
              ) +
              theme_minimal(base_size = 14) +
              theme(legend.position = "bottom")
            
            print(p)
            
          }, error = function(e) {
            cat("Erreur lmer:", e$message, "\n")
          })
        } else {
          cat("Pas assez de valeurs uniques pour modéliser (minimum 3 requis)\n")
        }
      } else {
        cat("Pas assez de données pour cet epoch (minimum 10 requis)\n")
      }
    }
  } else {
    cat("Pas assez de données globales pour cette analyse (minimum 20 requis)\n")
  }
}


diagnose_data()

# Exécuter l'analyse corrigée pour chaque domaine ASQ3
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("ANALYSES DE MODÉRATION ASQ3 (VERSION CORRIGÉE)\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

asq3_results_corrected <- list()

for (domain in asq3_domains) {
  if (domain %in% colnames(data.gca)) {
    cat("\n Traitement du domaine:", domain, "\n")
    results <- analyze_asq3_moderator(domain)
    asq3_results_corrected[[domain]] <- results
  } else {
    cat(" ATTENTION: Domaine ASQ3", domain, "introuvable dans les données\n")
  }
}

# Résumé final amélioré
cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("RÉSUMÉ FINAL DÉTAILLÉ\n")
cat(paste(rep("=", 80), collapse = ""), "\n")

for (domain in names(asq3_results_corrected)) {
  cat("\n DOMAINE:", toupper(domain), "\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  domain_results <- asq3_results_corrected[[domain]]
  
  if (is.list(domain_results) && !is.null(names(domain_results))) {
    for (epoch_name in names(domain_results)) {
      epoch_result <- domain_results[[epoch_name]]
      cat(" Epoch", epoch_name, ":")
      
      if ("model" %in% names(epoch_result)) {
        n_sig <- length(epoch_result$significance$significant_effects)
        cat("  Analysée (", n_sig, " effets significatifs)\n")
      } else if ("error" %in% names(epoch_result)) {
        cat(" ? Erreur:", epoch_result$error, "\n")
      } else if ("issue" %in% names(epoch_result)) {
        cat("  Problème:", epoch_result$issue, "\n")
      } else {
        cat("  Statut inconnu\n")
      }
    }
  } else {
    cat("  Résultats non disponibles\n")
  }
}

save_asq3_results <- function() {
  output_file <- "ASQ3_PC6_GCA_Results.txt"
  
  sink(output_file, append = FALSE)
  
  
  cat("MODÈLE PRINCIPAL (Age × Epoch):\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  print(summary(lmer_main))
  print(Anova(lmer_main, type = 3))
  
  cat("\n\nRÉSULTATS MODÉRATION ASQ3:\n")
  cat(paste(rep("-", 40), collapse = ""), "\n")
  
  for (domain in names(asq3_results)) {
    if (!is.null(asq3_results[[domain]])) {
      cat("\nDOMAINE:", toupper(domain), "\n")
      print(asq3_results[[domain]])
    }
  }
  
  sink()
   
  cat("Résultats sauvegardés dans:", output_file, "\n")
}

save_asq3_results()

```
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
