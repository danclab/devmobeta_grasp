---
title: "GCA analysis"
output:
  html_document:
    df_print: paged
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 
```{r GCA PC1}
library(dplyr)
library(car)
library(ggplot2)
library(lme4)
library(emmeans)
library(ggeffects)

three_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_three.csv')
six_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_six.csv')
twelve_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_twelve.csv')

merged_df <- bind_rows(
  mutate(three_df, df_source ="three"),
  mutate(six_df, df_source = "six"),
  mutate(twelve_df, df_source = "twelve")
) %>%
  arrange(subject)

# Result 
head(merged_df)
merged_df$age[merged_df$age=='three']<-3
merged_df$age[merged_df$age=='six']<-6
merged_df$age[merged_df$age=='twelve']<-12
merged_df$age<-as.numeric(merged_df$age)

predictor <- "age"
poly.order <- 2
orthogonal <- TRUE
names(merged_df)
code.poly <- function(df=NULL, predictor=NULL, poly.order=NULL, orthogonal=TRUE, draw.poly=TRUE){
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal-1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)){
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[,which(colnames(df)==predictor)]
  predictor.vector <- df[[predictor]] 
  
  # create index of predictor (e.g. numbered time bins)
  # the index of the time bin will be used later as an index to call the time sample
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  #create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw=raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  # (as many as called for by the polynomial order)
  df[, paste("poly", 1:poly.order, sep="")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE){
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep=""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars=predictor)
    
    # Make level names intuitive
    # don't bother with anything above 6th order.
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly2"] <- "Quadratic"
    # levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly3"] <- "Cubic"
    # levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly4"] <- "Quartic"
    # levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly5"] <- "Quintic"
    # levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly6"] <- "Sextic"
    #
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y=value, color=Order))+
      aes_string(x=predictor)+
      geom_line()+
      xlab(paste0(predictor, " (transformed polynomials)"))+
      ylab("Transformed value")+
      scale_color_brewer(palette="Set1")+
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor,".Index")
  return(df)
}

data.gca <- code.poly(df=merged_df, predictor="age", poly.order=2, orthogonal=TRUE, draw.poly=TRUE)

lmer_model <- lmer(PC1 ~ epoch*(poly1+poly2)+(1|subject), data = data.gca, REML = TRUE)
print(lmer_model)

lmer_results<-Anova(lmer_model, type = 3)
print(lmer_results)


em<-emtrends(lmer_model, ~epoch, var="poly1")
summary(em, infer = c(TRUE, TRUE))

em<-emtrends(lmer_model, ~epoch, var="poly2")
summary(em, infer = c(TRUE, TRUE))

ggplot(data.gca, aes(x = factor(age), y = PC1, fill = epoch)) +
  geom_violin(alpha = 0.7, position = position_dodge(width = 0.9)) +
  geom_boxplot(width = 0.2, alpha = 0.8, 
               position = position_dodge(width = 0.9)) +
  geom_point(aes(color = epoch), 
             position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.1), 
             alpha = 0.6, size = 1) +
  labs(title = "Distribution de PC1 par âge et époque (Violin plot)",
       x = "Âge", y = "PC4") +
  theme_bw()

summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC1 = mean(PC1, na.rm = TRUE),
    se_PC1 = sd(PC1, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

ggplot(summary_data, aes(x = age, y = mean_PC1, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC1 - se_PC1, ymax = mean_PC1 + se_PC1), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC1 par âge et époque",
       x = "Âge", y = "PC1 moyen ± SE") +
  theme_bw()

predictions <- ggpredict(lmer_model, terms = c("poly1 [all]", "epoch"))

plot(predictions) +
  labs(title = "Prédictions du modèle GCA pour PC1",
       x = "Polynôme linéaire (âge transformé)",
       y = "PC1 prédit") +
  theme_bw()
```
```{r GCA PC2}
library(dplyr)
library(car)
library(ggplot2)
library(lme4)
library(emmeans)
library(ggeffects)

three_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_three.csv')
six_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_six.csv')
twelve_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_twelve.csv')

merged_df <- bind_rows(
  mutate(three_df, df_source ="three"),
  mutate(six_df, df_source = "six"),
  mutate(twelve_df, df_source = "twelve")
) %>%
  arrange(subject)

# Result 
head(merged_df)
merged_df$age[merged_df$age=='three']<-3
merged_df$age[merged_df$age=='six']<-6
merged_df$age[merged_df$age=='twelve']<-12
merged_df$age<-as.numeric(merged_df$age)

predictor <- "age"
poly.order <- 2
orthogonal <- TRUE
names(merged_df)
code.poly <- function(df=NULL, predictor=NULL, poly.order=NULL, orthogonal=TRUE, draw.poly=TRUE){
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal-1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)){
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[,which(colnames(df)==predictor)]
  predictor.vector <- df[[predictor]] 
  
  # create index of predictor (e.g. numbered time bins)
  # the index of the time bin will be used later as an index to call the time sample
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  #create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw=raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  # (as many as called for by the polynomial order)
  df[, paste("poly", 1:poly.order, sep="")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE){
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep=""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars=predictor)
    
    # Make level names intuitive
    # don't bother with anything above 6th order.
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y=value, color=Order))+
      aes_string(x=predictor)+
      geom_line()+
      xlab(paste0(predictor, " (transformed polynomials)"))+
      ylab("Transformed value")+
      scale_color_brewer(palette="Set1")+
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor,".Index")
  return(df)
}

data.gca <- code.poly(df=merged_df, predictor="age", poly.order=2, orthogonal=TRUE, draw.poly=TRUE)

lmer_model <- lmer(PC2 ~ epoch*(poly1+poly2)+(1|subject), data = data.gca, REML = TRUE)
print(lmer_model)

lmer_results<-Anova(lmer_model, type = 3)
print(lmer_results)


em<-emtrends(lmer_model, ~epoch, var="poly1")
summary(em, infer = c(TRUE, TRUE))

em<-emtrends(lmer_model, ~epoch, var="poly2")
summary(em, infer = c(TRUE, TRUE))


ggplot(data.gca, aes(x = factor(age), y = PC2, fill = epoch)) +
  geom_violin(alpha = 0.7, position = position_dodge(width = 0.9)) +
  geom_boxplot(width = 0.2, alpha = 0.8, 
               position = position_dodge(width = 0.9)) +
  geom_point(aes(color = epoch), 
             position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.1), 
             alpha = 0.6, size = 1) +
  labs(title = "Distribution de PC2 par âge et époque (Violin plot)",
       x = "Âge", y = "PC2") +
  theme_bw()

summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC2 = mean(PC2, na.rm = TRUE),
    se_PC2 = sd(PC2, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

ggplot(summary_data, aes(x = age, y = mean_PC2, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC2 - se_PC2, ymax = mean_PC2 + se_PC2), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC2 par âge et époque",
       x = "Âge", y = "PC2 moyen ± SE") +
  theme_bw()

predictions <- ggpredict(lmer_model, terms = c("poly1 [all]", "epoch"))

plot(predictions) +
  labs(title = "Prédictions du modèle GCA pour PC2",
       x = "Polynôme linéaire (âge transformé)",
       y = "PC2 prédit") +
  theme_bw()
```
```{r GCA PC3}
library(dplyr)
library(car)
library(ggplot2)
library(lme4)
library(emmeans)
library(ggeffects)

three_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_three.csv')
six_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_six.csv')
twelve_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_twelve.csv')

merged_df <- bind_rows(
  mutate(three_df, df_source ="three"),
  mutate(six_df, df_source = "six"),
  mutate(twelve_df, df_source = "twelve")
) %>%
  arrange(subject)

# Result 
head(merged_df)
merged_df$age[merged_df$age=='three']<-3
merged_df$age[merged_df$age=='six']<-6
merged_df$age[merged_df$age=='twelve']<-12
merged_df$age<-as.numeric(merged_df$age)

predictor <- "age"
poly.order <- 2
orthogonal <- TRUE
names(merged_df)
code.poly <- function(df=NULL, predictor=NULL, poly.order=NULL, orthogonal=TRUE, draw.poly=TRUE){
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal-1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)){
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[,which(colnames(df)==predictor)]
  predictor.vector <- df[[predictor]] 
  
  # create index of predictor (e.g. numbered time bins)
  # the index of the time bin will be used later as an index to call the time sample
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  #create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw=raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  # (as many as called for by the polynomial order)
  df[, paste("poly", 1:poly.order, sep="")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE){
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep=""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars=predictor)
    
    # Make level names intuitive
    # don't bother with anything above 6th order.
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y=value, color=Order))+
      aes_string(x=predictor)+
      geom_line()+
      xlab(paste0(predictor, " (transformed polynomials)"))+
      ylab("Transformed value")+
      scale_color_brewer(palette="Set1")+
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor,".Index")
  return(df)
}

data.gca <- code.poly(df=merged_df, predictor="age", poly.order=2, orthogonal=TRUE, draw.poly=TRUE)

lmer_model <- lmer(PC3 ~ epoch*(poly1+poly2)+(1|subject), data = data.gca, REML = TRUE)
print(lmer_model)

lmer_results<-Anova(lmer_model, type = 3)
print(lmer_results)


em<-emtrends(lmer_model, ~epoch, var="poly1")
summary(em, infer = c(TRUE, TRUE))

em<-emtrends(lmer_model, ~epoch, var="poly2")
summary(em, infer = c(TRUE, TRUE))


ggplot(data.gca, aes(x = factor(age), y = PC3, fill = epoch)) +
  geom_violin(alpha = 0.7, position = position_dodge(width = 0.9)) +
  geom_boxplot(width = 0.2, alpha = 0.8, 
               position = position_dodge(width = 0.9)) +
  geom_point(aes(color = epoch), 
             position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.1), 
             alpha = 0.6, size = 1) +
  labs(title = "Distribution de PC3 par âge et époque (Violin plot)",
       x = "Âge", y = "PC3") +
  theme_bw()

summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC3 = mean(PC3, na.rm = TRUE),
    se_PC3 = sd(PC3, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

ggplot(summary_data, aes(x = age, y = mean_PC3, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC3 - se_PC3, ymax = mean_PC3 + se_PC3), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC3 par âge et époque",
       x = "Âge", y = "PC3 moyen ± SE") +
  theme_bw()

predictions <- ggpredict(lmer_model, terms = c("poly1 [all]", "epoch"))

plot(predictions) +
  labs(title = "Prédictions du modèle GCA pour PC3",
       x = "Polynôme linéaire (âge transformé)",
       y = "PC3 prédit") +
  theme_bw()
```

```{r GCA PC4}
library(dplyr)
library(car)
library(ggplot2)
library(lme4)
library(ggeffects)

three_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_three.csv')
six_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_six.csv')
twelve_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_twelve.csv')

merged_df <- bind_rows(
  mutate(three_df, df_source ="three"),
  mutate(six_df, df_source = "six"),
  mutate(twelve_df, df_source = "twelve")
) %>%
  arrange(subject)

# Result 
head(merged_df)
merged_df$age[merged_df$age=='three']<-3
merged_df$age[merged_df$age=='six']<-6
merged_df$age[merged_df$age=='twelve']<-12
merged_df$age<-as.numeric(merged_df$age)

predictor <- "age"
poly.order <- 2
orthogonal <- TRUE
names(merged_df)
code.poly <- function(df=NULL, predictor=NULL, poly.order=NULL, orthogonal=TRUE, draw.poly=TRUE){
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal-1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)){
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[,which(colnames(df)==predictor)]
  predictor.vector <- df[[predictor]] 
  
  # create index of predictor (e.g. numbered time bins)
  # the index of the time bin will be used later as an index to call the time sample
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  #create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw=raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  # (as many as called for by the polynomial order)
  df[, paste("poly", 1:poly.order, sep="")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE){
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep=""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars=predictor)
    
    # Make level names intuitive
    # don't bother with anything above 6th order.
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y=value, color=Order))+
      aes_string(x=predictor)+
      geom_line()+
      xlab(paste0(predictor, " (transformed polynomials)"))+
      ylab("Transformed value")+
      scale_color_brewer(palette="Set1")+
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor,".Index")
  return(df)
}

data.gca <- code.poly(df=merged_df, predictor="age", poly.order=2, orthogonal=TRUE, draw.poly=TRUE)

lmer_model <- lmer(PC4 ~ epoch*(poly1+poly2)+(1|subject), data = data.gca, REML = TRUE)
print(lmer_model)

lmer_results<-Anova(lmer_model, type = 3)
print(lmer_results)

em<-emtrends(lmer_model, ~epoch, var="poly1")
summary(em, infer = c(TRUE, TRUE))

ggplot(data.gca, aes(x = factor(age), y = PC4, fill = epoch)) +
  geom_violin(alpha = 0.7, position = position_dodge(width = 0.9)) +
  geom_boxplot(width = 0.2, alpha = 0.8, 
               position = position_dodge(width = 0.9)) +
  geom_point(aes(color = epoch), 
             position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.1), 
             alpha = 0.6, size = 1) +
  labs(title = "Distribution de PC4 par âge et époque (Violin plot)",
       x = "Âge", y = "PC4") +
  theme_bw()

summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC4 = mean(PC4, na.rm = TRUE),
    se_PC4 = sd(PC4, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

ggplot(summary_data, aes(x = age, y = mean_PC4, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC4 - se_PC4, ymax = mean_PC4 + se_PC4), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC4 par âge et époque",
       x = "Âge", y = "PC4 score ± SE") +
  theme_bw()

predictions <- ggpredict(lmer_model, terms = c("poly2 [all]", "epoch"))

plot(predictions) +
  labs(title = "Prédictions du modèle GCA pour PC4",
       x = "Polynôme quadratique (âge transformé)",
       y = "PC4 prédit") +
  theme_bw()

```
```{r GCA PC5}
library(dplyr)
library(car)
library(ggplot2)
library(lme4)
library(emmeans)
library(ggeffects)

three_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_three.csv')
six_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_six.csv')
twelve_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_twelve.csv')

merged_df <- bind_rows(
  mutate(three_df, df_source ="three"),
  mutate(six_df, df_source = "six"),
  mutate(twelve_df, df_source = "twelve")
) %>%
  arrange(subject)

# Result 
head(merged_df)
merged_df$age[merged_df$age=='three']<-3
merged_df$age[merged_df$age=='six']<-6
merged_df$age[merged_df$age=='twelve']<-12
merged_df$age<-as.numeric(merged_df$age)

predictor <- "age"
poly.order <- 2
orthogonal <- TRUE
names(merged_df)
code.poly <- function(df=NULL, predictor=NULL, poly.order=NULL, orthogonal=TRUE, draw.poly=TRUE){
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal-1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)){
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[,which(colnames(df)==predictor)]
  predictor.vector <- df[[predictor]] 
  
  # create index of predictor (e.g. numbered time bins)
  # the index of the time bin will be used later as an index to call the time sample
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  #create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw=raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  # (as many as called for by the polynomial order)
  df[, paste("poly", 1:poly.order, sep="")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE){
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep=""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars=predictor)
    
    # Make level names intuitive
    # don't bother with anything above 6th order.
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y=value, color=Order))+
      aes_string(x=predictor)+
      geom_line()+
      xlab(paste0(predictor, " (transformed polynomials)"))+
      ylab("Transformed value")+
      scale_color_brewer(palette="Set1")+
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor,".Index")
  return(df)
}

data.gca <- code.poly(df=merged_df, predictor="age", poly.order=2, orthogonal=TRUE, draw.poly=TRUE)

lmer_model <- lmer(PC5 ~ epoch*(poly1+poly2)+(1|subject), data = data.gca, REML = TRUE)
print(lmer_model)

lmer_results<-Anova(lmer_model, type = 3)
print(lmer_results)


em<-emtrends(lmer_model, ~epoch, var="poly1")
summary(em, infer = c(TRUE, TRUE))

ggplot(data.gca, aes(x = factor(age), y = PC1, fill = epoch)) +
  geom_violin(alpha = 0.7, position = position_dodge(width = 0.9)) +
  geom_boxplot(width = 0.2, alpha = 0.8, 
               position = position_dodge(width = 0.9)) +
  geom_point(aes(color = epoch), 
             position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.1), 
             alpha = 0.6, size = 1) +
  labs(title = "Distribution de PC5 par âge et époque (Violin plot)",
       x = "Âge", y = "PC5") +
  theme_bw()

summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC5 = mean(PC5, na.rm = TRUE),
    se_PC5 = sd(PC5, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

ggplot(summary_data, aes(x = age, y = mean_PC5, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC5 - se_PC5, ymax = mean_PC5 + se_PC5), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC5 par âge et époque",
       x = "Âge", y = "PC5 moyen ± SE") +
  theme_bw()

predictions <- ggpredict(lmer_model, terms = c("poly1 [all]", "epoch"))

plot(predictions) +
  labs(title = "Prédictions du modèle GCA pour PC5",
       x = "Polynôme linéaire (âge transformé)",
       y = "PC5 prédit") +
  theme_bw()
```
```{r GCA PC6}
library(dplyr)
library(car)
library(ggplot2)
library(lme4)
library(emmeans)
library(ggeffects)

three_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_three.csv')
six_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_six.csv')
twelve_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_twelve.csv')

merged_df <- bind_rows(
  mutate(three_df, df_source ="three"),
  mutate(six_df, df_source = "six"),
  mutate(twelve_df, df_source = "twelve")
) %>%
  arrange(subject)

# Result 
head(merged_df)
merged_df$age[merged_df$age=='three']<-3
merged_df$age[merged_df$age=='six']<-6
merged_df$age[merged_df$age=='twelve']<-12
merged_df$age<-as.numeric(merged_df$age)

predictor <- "age"
poly.order <- 2
orthogonal <- TRUE
names(merged_df)
code.poly <- function(df=NULL, predictor=NULL, poly.order=NULL, orthogonal=TRUE, draw.poly=TRUE){
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal-1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)){
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[,which(colnames(df)==predictor)]
  predictor.vector <- df[[predictor]] 
  
  # create index of predictor (e.g. numbered time bins)
  # the index of the time bin will be used later as an index to call the time sample
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  #create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw=raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  # (as many as called for by the polynomial order)
  df[, paste("poly", 1:poly.order, sep="")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE){
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep=""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars=predictor)
    
    # Make level names intuitive
    # don't bother with anything above 6th order.
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y=value, color=Order))+
      aes_string(x=predictor)+
      geom_line()+
      xlab(paste0(predictor, " (transformed polynomials)"))+
      ylab("Transformed value")+
      scale_color_brewer(palette="Set1")+
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor,".Index")
  return(df)
}

data.gca <- code.poly(df=merged_df, predictor="age", poly.order=2, orthogonal=TRUE, draw.poly=TRUE)

lmer_model <- lmer(PC6 ~ epoch*(poly1+poly2)+(1|subject), data = data.gca, REML = TRUE)
print(lmer_model)

lmer_results<-Anova(lmer_model, type = 3)
print(lmer_results)


em<-emtrends(lmer_model, ~epoch, var="poly1")
summary(em, infer = c(TRUE, TRUE))

ggplot(data.gca, aes(x = factor(age), y = PC6, fill = epoch)) +
  geom_violin(alpha = 0.7, position = position_dodge(width = 0.9)) +
  geom_boxplot(width = 0.2, alpha = 0.8, 
               position = position_dodge(width = 0.9)) +
  geom_point(aes(color = epoch), 
             position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.1), 
             alpha = 0.6, size = 1) +
  labs(title = "Distribution de PC6 par âge et époque (Violin plot)",
       x = "Âge", y = "PC6") +
  theme_bw()

summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC6 = mean(PC6, na.rm = TRUE),
    se_PC6 = sd(PC6, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

ggplot(summary_data, aes(x = age, y = mean_PC6, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC6 - se_PC6, ymax = mean_PC6 + se_PC6), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC6 par âge et époque",
       x = "Âge", y = "PC6 moyen ± SE") +
  theme_bw()

predictions <- ggpredict(lmer_model, terms = c("poly1 [all]", "epoch"))

plot(predictions) +
  labs(title = "Prédictions du modèle GCA pour PC6",
       x = "Polynôme linéaire (âge transformé)",
       y = "PC6 prédit") +
  theme_bw()
```

```{r GCA PC7}
library(dplyr)
library(car)
library(ggplot2)
library(lme4)
library(emmeans)
library(ggeffects)

three_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_three.csv')
six_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_six.csv')
twelve_df<-read.csv('/home/ldurieux/devmobeta_grasp/bursts_with_pc_twelve.csv')

merged_df <- bind_rows(
  mutate(three_df, df_source ="three"),
  mutate(six_df, df_source = "six"),
  mutate(twelve_df, df_source = "twelve")
) %>%
  arrange(subject)

# Result 
head(merged_df)
merged_df$age[merged_df$age=='three']<-3
merged_df$age[merged_df$age=='six']<-6
merged_df$age[merged_df$age=='twelve']<-12
merged_df$age<-as.numeric(merged_df$age)

predictor <- "age"
poly.order <- 2
orthogonal <- TRUE
names(merged_df)
code.poly <- function(df=NULL, predictor=NULL, poly.order=NULL, orthogonal=TRUE, draw.poly=TRUE){
  require(reshape2)
  require(ggplot2)
  
  # convert choice for orthogonal into choice for raw
  raw <- (orthogonal-1)^2
  
  # make sure that the declared predictor is actually present in the data.frame
  if (!predictor %in% names(df)){
    warning(paste0(predictor, " is not a variable in your data frame. Check spelling and try again"))
  }
  
  # Extract the vector to be used as the predictor
  predictor.vector <- df[,which(colnames(df)==predictor)]
  predictor.vector <- df[[predictor]] 
  
  # create index of predictor (e.g. numbered time bins)
  # the index of the time bin will be used later as an index to call the time sample
  predictor.indices <- as.numeric(as.factor(predictor.vector))
  
  df$temp.predictor.index <- predictor.indices
  
  #create x-order order polys (orthogonal if not raw)
  predictor.polynomial <- poly(x = unique(sort(predictor.vector)),
                               degree = poly.order, raw=raw)
  
  # use predictor index as index to align
  # polynomial-transformed predictor values with original dataset
  # (as many as called for by the polynomial order)
  df[, paste("poly", 1:poly.order, sep="")] <-
    predictor.polynomial[predictor.indices, 1:poly.order]
  
  # draw a plot of the polynomial transformations, if desired
  if (draw.poly == TRUE){
    # extract the polynomials from the df
    df.poly <- unique(df[c(predictor, paste("poly", 1:poly.order, sep=""))])
    
    # melt from wide to long format
    df.poly.melt <- melt(df.poly, id.vars=predictor)
    
    # Make level names intuitive
    # don't bother with anything above 6th order.
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly1"] <- "Linear"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly2"] <- "Quadratic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly3"] <- "Cubic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly4"] <- "Quartic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly5"] <- "Quintic"
    levels(df.poly.melt$variable)[levels(df.poly.melt$variable)=="poly6"] <- "Sextic"
    
    # change some column names for the output
    colnames(df.poly.melt)[colnames(df.poly.melt) == "variable"] <- "Order"
    
    poly.plot <- ggplot(df.poly.melt, aes(y=value, color=Order))+
      aes_string(x=predictor)+
      geom_line()+
      xlab(paste0(predictor, " (transformed polynomials)"))+
      ylab("Transformed value")+
      scale_color_brewer(palette="Set1")+
      theme_bw()
    
    print(poly.plot)
  }
  
  # restore correct column names
  colnames(df)[colnames(df) == "temp.predictor.index"] <- paste0(predictor,".Index")
  return(df)
}

data.gca <- code.poly(df=merged_df, predictor="age", poly.order=2, orthogonal=TRUE, draw.poly=TRUE)

lmer_model <- lmer(PC7 ~ epoch*(poly1+poly2)+(1|subject), data = data.gca, REML = TRUE)
print(lmer_model)

lmer_results<-Anova(lmer_model, type = 3)
print(lmer_results)


em<-emtrends(lmer_model, ~epoch, var="poly1")
summary(em, infer = c(TRUE, TRUE))

ggplot(data.gca, aes(x = factor(age), y = PC7, fill = epoch)) +
  geom_violin(alpha = 0.7, position = position_dodge(width = 0.9)) +
  geom_boxplot(width = 0.2, alpha = 0.8, 
               position = position_dodge(width = 0.9)) +
  geom_point(aes(color = epoch), 
             position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.1), 
             alpha = 0.6, size = 1) +
  labs(title = "Distribution de PC7 par âge et époque (Violin plot)",
       x = "Âge", y = "PC7") +
  theme_bw()

summary_data <- data.gca %>%
  group_by(age, epoch) %>%
  summarise(
    mean_PC7 = mean(PC7, na.rm = TRUE),
    se_PC7 = sd(PC7, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

ggplot(summary_data, aes(x = age, y = mean_PC7, color = epoch)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean_PC7 - se_PC7, ymax = mean_PC7 + se_PC7), 
                width = 0.2) +
  labs(title = "Évolution moyenne de PC7 par âge et époque",
       x = "Âge", y = "PC7 moyen ± SE") +
  theme_bw()

predictions <- ggpredict(lmer_model, terms = c("poly1 [all]", "epoch"))

plot(predictions) +
  labs(title = "Prédictions du modèle GCA pour PC7",
       x = "Polynôme linéaire (âge transformé)",
       y = "PC7 prédit") +
  theme_bw()
```




Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
